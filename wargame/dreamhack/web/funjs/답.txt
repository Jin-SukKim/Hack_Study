funjs
출제된 CTF: Dreamhack CTF Season 1 Round #4
분야: Web
키워드: javascript, obfuscation
난이도: ★☆☆☆☆
배경
자바스크립트는 웹을 사용하는 사용자의 다양한 액션/이벤트 등을 처리하여 웹과 사용자가 상호 작용할 수 있도록 도와주는 언어입니다. 상호 작용을 위해 자바스크립트내에 서비스의 정보가 포함되는 경우가 존재하며, 그 정보 또는 로직을 숨기기 위해 자바스크립트를 사람이 한 눈에 파악하기 힘들도록 난독화하는 경우가 존재합니다. 해당 문제에서는 난독화(obfuscation)를 접해보고, 난독화를 해제(deobfuscation)하는 것에 의의를 두고 있습니다.

풀이
입력 폼에 데이터를 입력하여 맞으면 플래그, 틀리면 NOP !을 출력하는 HTML 페이지입니다.
main 함수를 분석하여 올바른 입력 값을 찾으면 됩니다.

분석
디버깅을 방해하는 요소
  window.onload = init;
  function init() {
    box = document.getElementById("formbox");
    setInterval(moveBox,1000);
  }
  function moveBox() {
      box.posX = Math.random() * (window.innerWidth - 64); 
      box.posY = Math.random() * (document.documentElement.scrollHeight - 64); 
      box.style.marginLeft = box.posX + "px";
      box.style.marginTop  = box.posY + "px";
      debugger;
  }
웹 브라우저에서 개발자 도구를 이용해 분석 시, debugger 구문을 추가하여 원하는 구문에서 브레이크 포인트를 설정할 수 있습니다. 이런 점을 이용해 setInterval 등 지속적으로 실행되는 함수에 debugger 구문을 추가하여 사용자가 개발자 도구를 통해 소스코드를 분석하는 행위를 방해할 수 있습니다.

문자열 생성 로직
난독화 방법 중 주요 문자열을 동적으로 생성하는 로직이 존재합니다. 동적으로 문자열을 생성하는 로직은 아래와 같습니다.

var _0x1046=['2XStRDS','1388249ruyIdZ','length','23461saqTxt','9966Ahatiq','1824773xMtSgK','1918853csBQfH','175TzWLTY','flag','getElementById','94hQzdTH','NOP\x20!','11sVVyAj','37594TRDRWW','charCodeAt','296569AQCpHt','fromCharCode','1aqTvAU'];
var _0x376c = function(_0xed94a5, _0xba8f0f) {
    _0xed94a5 = _0xed94a5 - 0x175;
    var _0x1046bc = _0x1046[_0xed94a5];
    return _0x1046bc;
};
var _0x374fd6 = _0x376c;
(function(_0x24638d, _0x413a92) {
    var _0x138062 = _0x376c;
    while (!![]) {
        try {
            var _0x41a76b = -parseInt(_0x138062(0x17f)) + parseInt(_0x138062(0x180)) * -parseInt(_0x138062(0x179)) + -parseInt(_0x138062(0x181)) * -parseInt(_0x138062(0x17e)) + -parseInt(_0x138062(0x17b)) + -parseInt(_0x138062(0x177)) * -parseInt(_0x138062(0x17a)) + -parseInt(_0x138062(0x17d)) * -parseInt(_0x138062(0x186)) + -parseInt(_0x138062(0x175)) * -parseInt(_0x138062(0x184));
            if (_0x41a76b === _0x413a92) break;
            else _0x24638d['push'](_0x24638d['shift']());
        } catch (_0x114389) {
            _0x24638d['push'](_0x24638d['shift']());
        }
    }
}(_0x1046, 0xf3764));
전체적인 로직을 분석하는 방법도 있지만 결국은 해당 문자열을 로직에서도 사용하기 때문에 실행하여 원하는 문자열을 찾는 방법도 존재합니다. 위 로직을 개발자 도구등에서 실행 후 아래와 같이 동적으로 문자열을 생성하는 함수를 호출하게 되면 flag변수는 document['getElementById']('flag').value이라는 것을 알 수 있습니다.

var flag = document[_0x374fd6(0x183)](_0x374fd6(0x182))['value'],
/*
_0x374fd6(0x183); // getElementById
_0x374fd6(0x182); // flag
*/
비교 로직
_0x4949 = [0x20, 0x5e, 0x7b, 0xd2, 0x59, 0xb1, 0x34, 0x72, 0x1b, 0x69, 0x61, 0x3c, 0x11, 0x35, 0x65, 0x80, 0x9, 0x9d, 0x9, 0x3d, 0x22, 0x7b, 0x1, 0x9d, 0x59, 0xaa, 0x2, 0x6a, 0x53, 0xa7, 0xb, 0xcd, 0x25, 0xdf, 0x1, 0x9c],
_0x42931 = [0x24, 0x16, 0x1, 0xb1, 0xd, 0x4d, 0x1, 0x13, 0x1c, 0x32, 0x1, 0xc, 0x20, 0x2, 0x1, 0xe1, 0x2d, 0x6c, 0x6, 0x59, 0x11, 0x17, 0x35, 0xfe, 0xa, 0x7a, 0x32, 0xe, 0x13, 0x6f, 0x5, 0xae, 0xc, 0x7a, 0x61, 0xe1],
operator = [(_0x3a6862, _0x4b2b8f) => {
    return _0x3a6862 + _0x4b2b8f;
}, (_0xa50264, _0x1fa25c) => {
    return _0xa50264 - _0x1fa25c;
}, (_0x3d7732, _0x48e1e0) => {
    return _0x3d7732 * _0x48e1e0;
}, (_0x32aa3b, _0x53e3ec) => {
    return _0x32aa3b ^ _0x53e3ec;
}],
두개의 배열에 임의의 데이터가 선언되고 operator 변수에 +, -, *, ^ 연산의 함수가 순서대로 선언되는 것을 알 수 있습니다.

if (flag[_0x374fd6(0x17c)] != 0x24) { // _0x374fd6(0x17c) = length
    text2img(_0x374fd6(0x185)); // _0x374fd6(0x185) = "NOP !"
    return;
}
for (var i = 0x0; i < flag[_0x374fd6(0x17c)]; i++) {
    if (flag[_0x374fd6(0x176)](i) == operator[i % operator[_0x374fd6(0x17c)]](_0x4949[i], _0x42931[i])) {} // _0x374fd6(0x176) = charCodeAt
    else {
        text2img(_0x374fd6(0x185));
        return;
    }
}
flag의 길이를 비교하여 36글자가 아닌 경우와 두개의 배열을 순서대로 연산한 결과가 아닌 경우 NoP !이 출력되는 것을 알 수 있으며, 비교 구문이 모두 참이 되는 조건을 찾으면 된다는 것을 파악할 수 있습니다.

풀이코드
실제 로직을 아래와 같이 수정하면 성공적으로 플래그를 획득할 수 있습니다.

_0x4949 = [0x20, 0x5e, 0x7b, 0xd2, 0x59, 0xb1, 0x34, 0x72, 0x1b, 0x69, 0x61, 0x3c, 0x11, 0x35, 0x65, 0x80, 0x9, 0x9d, 0x9, 0x3d, 0x22, 0x7b, 0x1, 0x9d, 0x59, 0xaa, 0x2, 0x6a, 0x53, 0xa7, 0xb, 0xcd, 0x25, 0xdf, 0x1, 0x9c];
_0x42931 = [0x24, 0x16, 0x1, 0xb1, 0xd, 0x4d, 0x1, 0x13, 0x1c, 0x32, 0x1, 0xc, 0x20, 0x2, 0x1, 0xe1, 0x2d, 0x6c, 0x6, 0x59, 0x11, 0x17, 0x35, 0xfe, 0xa, 0x7a, 0x32, 0xe, 0x13, 0x6f, 0x5, 0xae, 0xc, 0x7a, 0x61, 0xe1];
operator = [(_0x3a6862, _0x4b2b8f) => {
    return _0x3a6862 + _0x4b2b8f;
}, (_0xa50264, _0x1fa25c) => {
    return _0xa50264 - _0x1fa25c;
}, (_0x3d7732, _0x48e1e0) => {
    return _0x3d7732 * _0x48e1e0;
}, (_0x32aa3b, _0x53e3ec) => {
    return _0x32aa3b ^ _0x53e3ec;
}];
var flag = "";
for (var i = 0x0; i < 36; i++) {
  flag += String.fromCharCode(operator[i % operator['length']](_0x4949[i], _0x42931[i]));
}
console.log(flag);