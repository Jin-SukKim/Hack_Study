puts("hello world!\n"); → x86_64 asm :
    hello world

    프로그래밍 언어를 배울 때 보통 가장 먼저 hello world! 를 출력해주는 프로그램을 시작으로 공부를 하게 됩니다.

    이 강의에서는 C로 짜여진 hello world! 를 출력하는 코드가 어떤식으로 어셈블리 코드로 바뀌었는지 
    확인해보는것을 통해 어셈블리 코드에 대한 기초와 C코드가 어떻게 어셈블리 코드으로 바뀌어 있는지 공부합니다.

    이 소스는 Windows에서 Visual Studio 2019를 통해 64비트 릴리즈 모드로 컴파일 하였으며, 프로그램명은 consoleapplication1 입니다.
    ex)
        #include <stdio.h>
        int main(){
            puts("hello world!\n");
            return 0;
        }

    하단에 보이는 어셈블리 코드는 x64dbg를 통해 main함수 일부분을 가져온 것입니다.
    보는 방법은 다음과 같습니다.

    1) 주소
        해당 어셈블리 코드의 시작 주소가 여기에 표시됩니다.

    2) 기계 코드
        사람이 읽을 수 있는 어셈블리 코드의 전 단계인 기계어가 여기에 표시되게 됩니다.
        : 앞에 있는 값은 prefix 이고 띄어쓰기 다음에 있는 부분은 어셈블리 코드의 2번째 인자 부분 입니다.

    3) 어셈블리어
        비교적 사람이 읽기 쉬운 형태인 어셈블리 코드가 여기에 표시됩니다.
        주소값의 경우 x64dbg가 적절한 형태로 바꾸어서 보여주기도 합니다. 3번째 줄을 보면 &puts라고 표시해주는것을 확인할 수 있습니다.

    4) 코멘트
        x64dbg가 프로그램을 분석하여 알게 된 추가적인 정보가 여기에 표시됩니다.
        2번째 줄을 보면 7FF6ED802220 에 있는 문자열에 대한 정보가 표시되는 것을 확인할 수 있습니다.
        여기서는 x64dbg를 기준으로 설명했지만 다른 디스어셈블러도 비슷한 형태로 표시해줍니다.
        다만 디스어셈블 창에 보이는 숫자는 설정에 따라 0x가 없어도 16진수로 읽어야 하는 경우가 많으며,
        하단에 나와있는 디스어셈블 결과의 경우 0x가 없지만 전부 16진수로 표기되어 있습니다.

    ex)
        7FF6ED801000 | 48:83EC 28       | sub rsp,28                          |
        7FF6ED801004 | 48:8D0D 15120000 | lea rcx,qword ptr ds:[7FF6ED802220] | 00007FF6ED802220:"hello world!\n"
        7FF6ED80100B | FF15 5F110000    | call qword ptr ds:[<&puts>]         |
        7FF6ED801011 | 33C0             | xor eax,eax                         |
        7FF6ED801013 | 48:83C4 28       | add rsp,28                          |
        7FF6ED801017 | C3               | ret                                 |







































