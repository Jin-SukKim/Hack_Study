Operand :
    명령 코드가 연산할 대상을 피연산자(Operand)라고 합니다.
    명령 코드를 함수라고 생각하면, 피연산자는 함수에 들어가는 인자라고 생각하면 조금 더 이해하기 쉽습니다.
    
    명령 코드에 따라 조금씩 다를 수 있지만,  Intel 방식의 어셈블리를 읽을 때에는 
    명령 코드에 따라 연산한 결과를 왼쪽 피연산자에 저장된다고 이해하는 것이 일반적입니다.

    명령 코드가 작업을 수행할 대상인 피연산자는 어떤 상수일 수도 있고, 레지스터에 들어 있는 값일 수도 있으며, 어떤 주소에 들어있는 값일 수도 있습니다.
    즉 피연산자를 어떻게 지정해 줄 것인지는 그 값을 사용할 방식에 따라 다양합니다.
    ex)
        mov   rbp,rsp      ; rbp = rsp
        mov   eax,0x0      ; eax = 0x0
        add   rcx,0x8      ; rcx = rcx+0x8
        dec   rcx          ; rcx = rcx-1

    Operand Types :
        주어진 명령 코드의 피연산자로는 상수, 레지스터, 혹은 레지스터가 가리키고 있는 메모리의 어떤 주소 가 올 수 있습니다.
        마지막 세 번째 경우는 C에서 프로그래밍을 할 때 자주 사용하는 포인터 개념과도 매우 밀접하게 연관되어 있습니다.

        1) 상수값(Immediate)
            가장 간단한 케이스로, 피연산자로 사용되는 값이 상수인 경우입니다.
            아래의 예시를 보면 mov 명령어의 피연산자 중 하나로 0xbeef가 사용되었습니다.
            ex)
                mov   rcx,0xbeef
                add   rcx,0x1337        // base 16 addition

            Q) 위의 어셈블리 코드가 실행되면 rcx 레지스터에 들어있는 값은 0xd226이 된다.

        2) 레지스터 
            레지스터도 피연산자로 사용될 수 있습니다.
            이 경우에는 레지스터에 들어있는 값이 피연산자로 사용됩니다.
            아래의 예시를 보면, mov 명령어의 결과로 rbx에 들어있는 값이 rcx에 들어가게 됩니다.
            ex)
                mov   rcx,rbx      ; rcx = rbx   
                sub   rcx,rax      ; rcx = rcx - rax
                
            Q) rbx=0xdead, rax=0xc0de일 때, 위의 어셈블리 코드가 실행되면 rcx 레지스터에 들어있는 값은 0x1dcf이다.

        3) Addressing Modes
            리버싱을 할 때 매우 자주 볼 수 있는 사례로, 레지스터에 있는 값이 피연산자가 되는 것이 아니라
            레지스터에 저장된 메모리 주소를 참조한 값이 피연산자가 되는 경우입니다.

            다시 말해 레지스터에 들어있는 값은 메모리 주소로, 실제로는 해당 메모리 주소를 참조한 값이 피연산자로 사용됩니다.
            이것은 앞서 말한 것과 같이 C언어의 포인터 개념과 유사합니다.

                - [reg] :
                    밑의 첫번째 예시를 보면, mov 명령어의 결과로 rax 에 들어있는 값을 rcx 레지스터가 참조하는 주소의 메모리에 저장하게 됩니다.
                    오른쪽의 두번째 예시에서 사용된 byte ptr은 Pointer Directive라고 하며,
                    앞서 공부한 Data Size가 실제 어셈블리 코드에서 사용된 케이스입니다.
                    즉 rax 레지스터가 저장하고 있는 값 중 하위 8bit, 곧 1byte만 rcx 가 참조하는 주소에 저장하게 됩니다.

            ex)
                mov   [rcx],rax                   ; *rcx = rax
                mov   byte ptr [rcx],al           ; *rcx = al
                mov   dword ptr [rbp-1Ch],eax      
                mov   byte ptr [rdi+rcx*4+3],0FFh 
                // 16진수를 나타낼 때 앞에 0x를 붙이기도 하고 뒤에 h를 붙이기도 합니다. 문법의 차이로 넘겨보면 될 것 같습니다.

            레지스터의 값이 메모리 주소로 바로 쓰이기도 하는 반면, 
            레지스터에 들어있는 값에서 특정 오프셋(offset)만큼 떨어진 주소값을 참조하기도 합니다.
            이렇게 읽으면 어렵게 들리지만 사실 C언어에서의 배열이나 구조체를 생각해보면 이해하기 쉽습니다.

                - [reg+d] :
                    레지스터에 들어있는 값을 주소의 기준으로 하여 d 만큼 떨어진 오프셋을 실제로 참조한 다음 피연산자로 씁니다.
                    위의 세번째 예시를 보면, rax 레지스터에 들어있는 값을 저장할 때 rbp 의 값을 참조한 메모리 주소에 바로 넣는 것이 아니라,
                    그 메모리 주소로부터 -0x1C 떨어진 곳을 계산하여 넣습니다.
                    여기서도 등장하는 Pointer Directive를 고려하면, DWORD에 해당하는 사이즈인 하위 4byte만 넣는 것을 알 수 있습니다.

                    // 1Ch가 0x1C가 되는 이유는 h 때문입니다.
                    // 만약 그냥 1C라고 한다면, DWORD 형식이기 때문에 0x001C가 됩니다. 또는 1Cl이라고 적어야겠지요.
                    // 그래서 h를 적어줘서 1Ch = 0x1C가 되는것 같네요. 자세히 적으면 0x1C00이 되지만, 0을 생략한것 같습니다.

                - [reg1+reg2] :
                    한 레지스터에 들어있는 값과 다른 레지스터에 들어있는 값을 더한 결과를 참조할 메모리 주소로 사용하는 경우입니다.
                    ex)
                        해당 참조는 대부분의 경우 index로 접근하는 경우에 해당합니다. 예를 들어 for(i=0;i<10;i++) arr[i]은 reg1에 arr의 주소가 담기고, 
                        reg2에는 i의 값이 담기는데, 이를 통해 reg2 값을 1씩 더해서 접근할 수 있죠.

                - [reg1+reg2*i+d] :
                    가장 복잡해 보이지만, 그만큼 많이 쓰이기도 합니다.
                    구조체가 사용된 경우 등에서 자주 보이는 방식입니다.
                    위의 예시 중 네번째를 보면 rdi 레지스터에 담긴 주소를 기준으로, rcx 레지스터의 값을 단위로 하여
                    4단위 떨어진 곳에 다시 offset 3만큼 더한 주소를 실제로 참조하고 있습니다.
                    여기에 1byte 사이즈의 값인 0xff가 저장됩니다.
                    reg2에 해당하는 레지스터에 담긴 값은 대개 자료형이나 구조체의 크기인 경우가 많습니다.

                    
ex)
    byte ptr [rcx], al
    byte ptr [rcx], ah
    1 번과 2 번 작동이 다른가요?
    제 생각으로는 1 번의 경우는 rcx 끝에서 1 바이트 위치에 al이 들어가고, 2 번의 경우 rcx 끝에서 2 바이트 위치에 ah가 들어간다고 생각되는데 맞나요?

    감사합니다.

    생각하신게 맞습니다. 저같은 경우는 ax가 있다면 al을 low로 봐서 끝에 위치한 1바이트로 판단하고, ah를 high로 al 앞에 위치한 1바이트로 판단합니다.



















