레지스터와 그 종류 :
    레지스터는 CPU가 사용하는 저장 공간입니다. 
    대개의 경우 각각의 레지스터들은 특별히 쓰임새가 정해져 있지 않습니다.
    그러나 쓰임새가 정해진 것은 아니지만 관행적으로 용도를 정해놓고 쓰는 레지스터도 있고,
    엄격히 정해진 용도로만 쓰이는 레지스터가 있기도 합니다.

범용 레지스터 (General-Purpose Registers, GPR) :
    말 그대로 용도를 특별히 정해두지 않고 다양하게 쓸 수 있는 레지스터입니다. 
    우리가 수학 계산을 할 때 연습장을 두고 쓰듯이, CPU도 범용 레지스터를 연습장처럼 씁니다.
    x64의 범용 레지스터는 총 16개로, 사진에 빨간 글씨로 표시된 레지스터들이 여기에 해당됩니다.
    ex)
        rax, rcx, rdx, r8, r9, r10, r11, 
        rbx, rsi, rbp, r12, r13, r14, r15, 
        rsp

    rax는 함수가 실행된 후 리턴값을 저장 하기 위해 쓰입니다.
    즉, 어떤 함수의 실행이 종료되고 나면 해당 함수의 결과값이 반환될 때 이 rax 레지스터에 담겨 반환됩니다.

    그러나 rax가 리턴값을 위해서만 쓰이는 것은 아닙니다. 
    함수가 반환되기 전까지 범용 레지스터로 자유롭게 사용되다가,
    종료 후 리턴값을 반환하기 위한 레지스터로는 rax만이 사용됩니다.

    x64의 범용 레지스터들 중에서는 함수가 실행될 때 필요한 인자들을 저장하는 용도로 사용하는 레지스터들도 있습니다. 
    이를 함수 호출 규약(Calling Convention) 이라고 부르며, 운영체제의 종류나 함수의 종류에 따라 조금씩 다릅니다. 
    이 강의에서는 Windows 64bit 환경에 대해 중점적으로 다루고 있으므로, Windows 64bit에서 사용하는 함수 호출 규약에 대해 알아보겠습니다.

    rcx, rdx, r8, r9는 Windows 64bit에서 함수를 호출할 때 필요한 인자들을 순서대로 저장합니다.
    즉 첫번째 인자는 rcx에, 두번째 인자는 rdx에… 하는 방식으로 인자를 레지스터에 담아 함수를 호출합니다.

    rax와 마찬가지로, 함수 호출 규약에서 쓰이는 레지스터들 역시 함수를 호출할 때 인자를 전달하는 용도로 이 레지스터들이 정해집니다.
    함수가 호출된 이후에는 이들 역시 범용 레지스터로 자유롭게 사용할 수 있습니다.

    rsp는 조금 특별합니다. 
    16개의 범용 레지스터들 중 하나로 분류되지만, 다른 범용 레지스터들과 달리 용도가 정해져 있습니다.
    rsp는 스택 포인터(Stack Pointer)로, 스택의 가장 위쪽 주소를 가리킵니다.
    스택은 함수가 사용할 지역 변수들(local variables)을 저장하기 위해 준비해놓는 공간입니다.

    스택과 rsp에 대해서는 스택 명령어를 공부할 때 보다 자세히 알아보겠습니다.


명령어 포인터 (Instruction Pointer) :
    ex)
        rip

    명령어 포인터는 범용 레지스터들과는 달리 그 용도가 엄격히 정해져 있는 레지스터입니다.

    명령어 포인터인 rip는 다음에 실행될 명령어가 위치한 주소를 가리키고 있습니다.
    즉 프로그램의 실행 흐름과 관련된 중요한 레지스터이므로, 범용으로 사용되지 않는 레지스터입니다.


Data Size :
    CPU가 사용하는 값의 크기 단위를 WORD라고 합니다. 
    오래 전 16bit CPU가 처음 등장했을 때 당시 CPU가 사용하는 값의 단위였던 16bit를 WORD라고 하면서,
    WORD 단위를 처리할 수 있는 범용 레지스터의 이름이 ax, cx, dx, bx로 붙은 것이 현재 우리가 사용하는 레지스터 이름의 기원이 되었습니다.
    시간이 흘러 32bit 단위로 레지스터의 크기가 커지면서(extended) 레지스터의 이름도 eax, ecx, edx, ebx 가 되었습니다.
    이후 64bit CPU에서 사용하는 레지스터 이름은 우리가 앞서 레지스터에 대해 공부한 바와 같습니다.
    (즉 16bit는 ax, cs, dx, bx, 32bit는 앞에 e가 붙고 64bit는 r이 붙는다)

    우리가 사용하는 64bit CPU인 x64의 레지스터들이 담을 수 있는 값의 크기는 64bit (8byte, QWORD)입니다.
    그러나 꼭 8byte 단위로만 값을 저장해야 하는 것은 아닙니다.
    
    사진과 같이 rcx 레지스터를 예로 들어 설명하면, 
    rcx 레지스터에 저장된 값 중 하위 32bit (4byte, DWORD)만 연산에 사용할 수도 있고,
    혹은 하위 16bit (2byte, WORD)나 하위 8bit (1byte, BYTE)만 사용하는 것도 가능합니다.
    이렇게 레지스터의 하위 비트만 접근하려면 어셈블리 코드에서 접근할 레지스터 이름으로 ecx, cx를 사용하면 됩니다.

    마찬가지로 r8~ r15 까지 64비트에서 새로 추가된 범용 레지스터들도 하위 일부 비트만 접근하여 사용하기 위해 다른 레지스터 이름을 사용할 수 있습니다.
    r8의 경우 r8d, r8w, r8b를 통해 각각 하위 32비트, 16비트, 8비트에 접근할 수 있습니다.
    이렇게 d, w, b 와 같은 접미사(suffix)를 붙이는 방식은 r8~ r15 레지스터들이 동일하게 사용합니다.
    (d = DWORD, 32bit, w = WORD, 16bit, b = bit)


FLAGS (상태 레지스터) :
    마지막으로 알아볼 레지스터는 상태 레지스터인 FLAGS 입니다.
    '깃발'을 의미하는 단어 뜻 그대로, 현재 상태나 조건을 0과 1로 나타내는 레지스터입니다. 
    앞서 본 레지스터들과 달리, FLAGS 레지스터를 구성하는 64개의 비트들 각각이 서로 다른 의미를 지닙니다.
    다시 말해 0번째 비트, 1번째 비트, 2번째 비트... 등 각각의 비트가 서로 다른 상태를 나타낸다고 볼 수 있습니다.

    몇 번째 비트가 어떤 플래그인지를 상세히 알 필요는 없지만(디버거에 어떤 플래그인지 표시되기 때문입니다.)
     몇 가지 중요한 플래그들에 대해서는 짚고 넘어가겠습니다.

        Flag Abbreviation      설명                                                                                                 예시
        
    CF (Carry Flag)         더하거나 빼는 등의 산술 연산 혹은 bit shift/rotate(레지스터에 저장된 값의 비트를 한 자리씩 옮기는 것)         CF.png
                            등의 연산이 일어났을 때, 자리 올림(carry)이 생기는 경우 CF의 값이 1이 됩니다.
                            CF의 특징은 연산에 사용된 값들에 부호가 없다는(unsigned) 점입니다.

    ZF (Zero Flag)          연산의 결과가 0일 때 ZF는 1이 됩니다. 아주 간단한 플래그이지만, 매우 널리 쓰입니다.                          ZF.png
                            예를 들어 두 값의 크기를 비교할 때 CPU는 한 값에서 다른 한 값을 빼는 방식으로 비교하는데, 
                            두 값이 같다면 연산의 결과가 0이 되어 ZF가 1이 되므로 
                            ZF의 값을 확인하면 비교한 두 대상의 값이 같은지를 확인할 수 있게 됩니다.

    SF (Sign Flag)          CF가 부호 없는(unsigned) 값의 연산에서 쓰인다면, SF는 부호가 있는 (signed) 값의 연산에서 쓰여서 결과가       SF.png
                            음수인지 혹은 양수인지를 가리킵니다. 수행한 결과가 양수일 때, 즉 최상위 비트가 0이면 SF=0, 
                            반대로 결과가 음수가 되어 최상위 비트가 1이면 SF=1이 됩니다.

    OF (Overflow Flag)      OF는 부호가 있는 (signed) 값의 연산에서 CF의 역할을 합니다.                                               OF.png
                            즉 부호가 없는 값을 연산할 때 자리 올림이 생길 경우 CF를 통해 표시했지만, 
                            연산에 사용된 값들에 부호가 있을 경우에는 CF 대신 OF를 사용합니다. 
                            ‘overflow’ 라는 이름에서 알 수 있듯이 부호 있는 값들을 대상으로 산술 연산을 했을 때 
                            자리 올림이 생겼다는 것은 표시할 수 있는 값의 범위를 넘어갔다(overflowed)는 것을 의미합니다.






