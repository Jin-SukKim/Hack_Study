Javascript Comparison Problem
    PHP와 마찬가지로 변수의 타입을 동적으로 정할 수 있는 Dynamic 언어.
    타입이 다른 두 변수의 값을 비교시 어떻게 되는지 알아보고 그 과정에서 발생할 수 있는 문제점을 알아보자

    두 값을 비교할 때 두 값 모두 객체가 아닐경우 valueOf, toString 함수를 이용해 원시 값(primitive value)을 가져와 비교하게 됩니다.

    var a = {}
    console.log(a.toString()); // [object Object]
    a.toString = () => 'dreamhack';
    console.log(a == 'dreamhack'); // true
    a.valueOf = () => 'dreamhack2';
    console.log(a == 'dreamhack2'); // true

    2번 라인은 객체 a의 문자열 원시 값을 가져온다.
    그 결과 [object object]인 것을 확인 가능

    4번 라인은 toString 함수를 dreamhack이라는 문자열을 반환하게 수정한 뒤 a 객체를 문자열과 비교합니다. 그 결과 true를 반환하는 것을 확인할 수 있습니다. 
    이를 통해 문자열과 비교할 경우 toString을 통해 문자열 원시 값을 가져온다는 사실을 알 수 있습니다.

    7번 라인에서는 toString 대신 valueOf 함수를 dreamhack2로 반환하는 함수로 수정합니다. 
    이번에는 dreamhack2와 비교를 해보면 마찬가지로 true를 반환하는 것을 볼 수 있습니다. 
    이를 통해 toString보다 valueOf 함수가 원시 값을 구하기 위해 먼저 호출된다는 것을 알 수 있습니다.

Array's String Primitive
    기본적으로 어떠한 문자열 원시 값을 반환하는지 

    var req = {secret: A}
    if ("secretValue" == req.secret) {
        data = req.secret.charAt(0)
        /* ... */
    }

    A 값을 수정해 3번 라인에서 익셉션이 발생하게 할 수 있습니다. 
    배열의 문자열 원시 값은 Array.join(array, ',')와 일치 합니다. 
    따라서 첫번째 요소가 secretValue인 배열을 A에 넣어주면 charAt을 찾지 못해 익셉션이 발생합니다.

    문자열 타입 입력 시
        var req = {secret: A}
        if ("secretValue" == req.secret) {
            data = req.secret.charAt(0)
        }
        // "s"

    배열 타입 입력시
        var req = {secret: ["secretValue"]}
        if ("secretValue" == req.secret) {
            data = req.secret.charAt(0);
        }
        // Uncaught TypeError: req.secret.charAt is not a function

    비교문에서는 정상적으로 검증되었지만, 이후 charAt함수호출 시 Array에는 존재하는 않는 함수이기 때문에 오류가 발생하게 됩니다











