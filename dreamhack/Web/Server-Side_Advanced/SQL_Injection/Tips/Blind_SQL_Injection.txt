Blind SQL Injection Tip - 1 :
    ASCII에서 출력 가능한 문자의 범위는 32~126 이며, 총 94개의 문자가 존재합니다.
    Blind SQL Injection을 통해 문자열을 추출할 때 하나의 문자를 구하기 위해 최악의 경우 94번의 요청을 전송해야하며 비효율적입니다.

    Blind SQL Injection을 좀 더 효율적으로 수행하는 방법들이 존재합니다. 
    대표적인 예시들에 대해 설명하도록 하겠습니다.

    1) Binary Search (이진 검색 알고리즘) :
        이진 검색 알고리즘은 정렬된 리스트에서 특정한 값을 찾는 알고리즘입니다.
        검색 과정을 간단히 설명하면 아래와 같습니다.

        1. 범위 내의 중간 값을 지정하고 값을 비교합니다.
            - 0~100 사이의 범위라면 50을 지정하고 찾고자 하는 값과 비교합니다.

        2. 지정한 값이 찾고자 하는 값과 비교하고 범위를 조절합니다.
            - 50보다 크다면 범위를 51~100으로 조절.
            - 50보다 작으면 범위를 0~49으로 조절.

        3. 위 과정을 반복하여 특정한 값을 찾습니다.

        해당 과정을 Blind SQL Injection에 적용하면 아래와 같습니다.
        데이터베이스에 아래와 같이 데이터가 있는 경우를 가정하고 설명하도록 하겠습니다
        ex)
            mysql> select * from users;
            +----------+------------------------+
            | username | password               |
            +----------+------------------------+
            | admin    | Password_for_admin     |
            +----------+------------------------+
            1 rows in set (0.00 sec)

        ord함수 등을 사용해 해당 문자를 int형으로 변경합니다.
        ex)
            mysql> SELECT if(ord(substr(password,1,1))>75, 1,0) FROM users;
            +---------------------------------------+
            | if(ord(substr(password,1,1))>75, 1,0) |
            +---------------------------------------+
            |                                     1 |
            +---------------------------------------+
            1 row in set (0.00 sec)

        위 쿼리의 결과를 통해 75보다 큰 수라는 것을 알 수 있습니다.
        ex)
            mysql> SELECT if(ord(substr(password,1,1))>101, 1,0) FROM users;
            +----------------------------------------+
            | if(ord(substr(password,1,1))>101, 1,0) |
            +----------------------------------------+
            |                                      0 |
            +----------------------------------------+
            1 row in set (0.00 sec)

        위 결과가 0이 나온 것을 통해 101보다는 작은 수라는 것을 알 수 있습니다.
        ex)
            mysql> SELECT if(ord(substr(password,1,1))>87, 1,0) FROM users;
            +---------------------------------------+
            | if(ord(substr(password,1,1))>87, 1,0) |
            +---------------------------------------+
            |                                     0 |
            +---------------------------------------+
            1 row in set (0.00 sec)
        
        위 결과가 0이 나온것을 통해 87보다는 작은 수라는 것을 알 수 있습니다.

        위의 행위를 반복하여 아래와 같이 최종적인 범위를 줄여가며 효율적인 검색을 수행할 수 있습니다.
        ex)
            mysql> SELECT if(ord(substr(password,1,1))=80, 1,0) FROM users;
            +---------------------------------------+
            | if(ord(substr(password,1,1))=80, 1,0) |
            +---------------------------------------+
            |                                     1 |
            +---------------------------------------+
            1 row in set (0.00 sec)

    2) bit 연산 :
        ASCII는 7개의 비트를 통해 하나의 문자를 나타냅니다.

        위 원리를 적용하여 바이트를 비트로 변환하면 7번의 요청을 통해 한 바이트를 획득할 수 있습니다.

        비트는 1과 0으로 이루어져있기 때문에 1에 대해 요청해서 거짓이 나오면 0이라는 것을 알 수 있습니다.
        ex)
            mysql> SELECT bin(ord('A'));
            +---------------+
            | bin(ord('A')) |
            +---------------+
            | 1000001       |
            +---------------+
            1 row in set (0.00 sec)
        
        위와 같이 MySQL에서는 bin 함수를 통해 int형을 bit형태로 변경할 수 있습니다.
        ex)
            mysql> SELECT substr(bin(ord('A')),1,1)=1;
            +-----------------------------+
            | substr(bin(ord('A')),1,1)=1 |
            +-----------------------------+
            |                           1 |
            +-----------------------------+
            1 row in set (0.01 sec)
            
            mysql> SELECT substr(bin(ord('A')),2,1)=1;
            +-----------------------------+
            | substr(bin(ord('A')),2,1)=1 |
            +-----------------------------+
            |                           0 |
            +-----------------------------+
            1 row in set (0.00 sec)
            ...
            
            mysql> SELECT substr(bin(ord('A')),7,1)=1;
            +-----------------------------+
            | substr(bin(ord('A')),7,1)=1 |
            +-----------------------------+
            |                           1 |
            +-----------------------------+
            1 row in set (0.00 sec)

        위와 같이 7번의 요청을 통해 binary값 1000001, 즉 "A"라는 것을 알 수 있습니다.



























