잘못된 확장자 검사 :
    파일명은 2개 이상의 확장자를 포함할 수 있으며, 점(.)문자 또한 업로드된 파일명 어디에도 존재할 수 있습니다.

    웹 서버의 설정마다 확장자를 인식하는 알고리즘이 달라질 수 있으며, 웹 애플리케이션 또한 이러한 인식 규칙에 맞추어 여과하여야 합니다.
    다음은 정규식에 따른 확장자 매칭 예시입니다.

        파일명      (\..*)          (\.[^.]*)       (\.[^.]*)$         [^.](\.[^.]*)$

    no-extension     -               -                   -                    -

    dream.php       dream.php       dream.php       dream.php           dream.php

    dream.tar.gz    dream.tar.gz    dream.tar.gz    dream.tar.gz        dream.tar.gz

    .bashrc         .bashrc         .bashrc         .bashrc             -

    dream.jpg.php   dream.jpg.php   dream.jpg.php   dream.jpg.php       dream.jpg.php

    .php            .php            .php            .php                -

    각 정규식을 요약하자면 다음과 같습니다.

        1) (\..*) - . 문자 뒤에 있는 모든 부분문자열을 매칭합니다.
            .jpg.php 확장자를 입력하면 뒤의 .php 를 분리하지 못해 완전히 다른 확장자로 인식하여 여과에 실패합니다.

        2) (\.[^.]*) - . 문자 뒤에 있는 모든 부분문자열을 매칭하나, 또다른 . 문자가 나오면 그 부분부터는 제외합니다.
            .jpg.php 확장자를 입력하면 .jpg 만 인식하여 여과에 실패합니다.

        3) (\.[^.]*)$ - 가장 마지막에 등장하는 . 문자 뒤에 있는 모든 부분을 매칭합니다.
            파일명 자체가 .으로 시작해도 이를 확장자로 간주하는 것을 볼 수 있습니다.
            만일 서버가 두 개 이상의 확장자를 인식한다면 여과에 실패할 수 있습니다.

        4) [^.](\.[^.]*)$ - 가장 마지막에 등장하는 . 문자 뒤에 있는 모든 부분을 매칭하나, 시작 부분의 .은 무시합니다.
            만일 서버가 확장자만 있는 파일명 자체를 확장자로 인식한다면 여과에 실패할 수 있습니다.

    정규식을 사용할 떄 한 가지 주의점을 덧붙이자면, 일부 정규식 모드에서는 $ 가 문자열 끝이 아닌 줄의 끝을 의미한다는 것입니다.
    따라서 dream.jpg\nactually.php (\n 은 줄바꿈 문자)와 같은 파일명을 사용하면 .jpg 로 인식될 수 있습니다.
    이를 공격할 때 URL 인코딩 상에서는 \n 을 %0A 로 바꾸면 됩니다.

    방어 시 일부 정규식 엔진 구현에서는 이러한 모호함을 없애기 위해 \Z 명령을 제공하고 있으나, 지원 여부가 다르니 사용하는 엔진의 문서를 참고하는 것이 좋습니다.



























