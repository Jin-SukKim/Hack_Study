Position Independent Executable(PIE) :
    이번 장에서는 ELF의 Position Independent Executable(PIE) 보호기법과 이를 우회하는 방법에 대해 배워보도록 하겠습니다.
    PIE는 Executable, 즉 바이너리가 로딩될 때 랜덤한 주소에 매핑되는 보호기법입니다. 
    PIE 보호기법의 원리는 공유 라이브러리와 비슷합니다.
    컴파일러는 바이너리가 메모리 어디에 매핑되어도 실행에 지장이 없도록 바이너리를 위치 독립적으로 컴파일합니다.
    이는 결국 코드 영역의 주소 랜덤화를 가능하게 해줍니다.
    PIE가 설정되어 있으면 코드 영역의 주소가 실행될 때마다 변하기 때문에 ROP와 같은 코드 재사용 공격을 막을 수 있습니다.

    no_pie.c와 pie.c는 main 함수의 주소를 출력해주는 소스코드입니다.
    ex) no_pie.c
        //gcc -o no_pie no_pie.c -m32
        #include <stdio.h>
        int main(void){
            printf("MAIN addr : 0x%p\n", &main);
        }
    
    ex) pie.c
        //gcc -o pie pie.c -m32 -fPIC -pie
        #include <stdio.h>
        int main(void){
            printf("MAIN addr : 0x%p\n", &main);
        }

    각 소스코드를 주어진 컴파일 옵션대로 컴파일하여 실행한 결과는 다음과 같습니다.
    ex)
        $ ./no_pie
        MAIN addr : 0x804840b
        $ ./no_pie
        MAIN addr : 0x804840b
        $ ./no_pie
        MAIN addr : 0x804840b
    
    ex)
        $ ./pie
        MAIN addr : 0x565bf5f0
        $ ./pie
        MAIN addr : 0x565985f0
        $ ./pie
        MAIN addr : 0x565d95f0  

    PIE 보호기법이 적용되어 있지 않은 no_pie의 main 함수 주소는 항상 0x804840b로 일정한 반면, 
    pie의 main 함수 주소는 실행될 때마다 변하는 것을 볼 수 있습니다.

    즉, PIE 가 설정되어 있으면 코드, 힙, 라이브러리, 스택 등 모든 메모리 영역의 주소가 랜덤화 됩니다.

    
































