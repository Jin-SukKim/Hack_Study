Bypassing Relocation Read-Only(RELRO) :
    ELF 바이너리에서 printf와 같이 동적으로 링크된 라이브러리의 함수를 호출할 때,
    호출된 함수의 주소를 찾기 위해 PLT(Procedure Linkage Table)와 GOT(Global Offset Table)를 사용한다는 것을 배웠습니다.
    GOT에는 처음에 라이브러리 함수의 주소를 구하는 바이너리 코드 영역 주소가 저장되어 있다가,
    함수가 처음 호출될 때 라이브러리 함수의 실제 주소가 저장됩니다.
    이렇듯 바이너리가 실행되는 도중, 함수가 처음 호출될 때 주소를 찾는 방식을 Lazy Binding이라고 합니다.

    Lazy Binding을 할 때는 프로그램이 실행되고 있는 도중 GOT에 라이브러리 함수의 주소를 덮어써야 하기 때문에 GOT에 쓰기 권한이 있어야 합니다. 
    GOT에 값을 쓸 수 있다는 특징 때문에 이전 장의 ROP 익스플로잇에 사용되었던 GOT Overwrite와 같은 공격이 가능합니다.

    하지만 Relocation Read-Only(RELRO) 보호기법이 설정되어 있으면 GOT와 같은 다이나믹 섹션이 읽기 권한만을 가지게 됩니다. 
    이번 장에서는 RELRO 보호기법과 이를 우회하여 익스플로잇하는 방법에 대해 배워보겠습니다.

    example7은 example7.c를 RELRO 옵션과 함께 컴파일한 바이너리입니다.
    ex)
        // gcc -o example7 example7.c -mpreferred-stack-boundary=2 -Wl,-z,relro,-z,now
        #include <stdio.h>
        void arbitrary_read(long * addr){
            printf("%lx\n", *addr);
        }
        void arbitrary_write(long *addr, long val){
            *addr = val;
        }
        void menu(void){
            puts("0. exit");
            puts("1. Leak Address");
            puts("2. Arbitrary Write");
        }
        int main(void){
        
            setvbuf(stdin, NULL, _IONBF, 0);
            setvbuf(stdout, NULL, _IONBF, 0);
            int choice = 0;
            long addr = 0;
            long value = 0;
            while(1){
                menu();
                scanf("%d", &choice);
                switch(choice){
                case 1:
                    printf("Which address? : ");
                    scanf("%lu", &addr);
                    
                    arbitrary_read(addr);
                    break;
                case 2:
                    printf("Address : ");
                    scanf("%lu", &addr);
                    printf("Value : ");
                    scanf("%lu", &value);
                    
                    arbitrary_write(addr, value);
                    break;
                
                case 0:
                    return 0;
                default:
                    break;
                }
            }
        }

    example7의 실행 결과는 다음과 같습니다.
    ex)
        0. exit
        1. Leak Address
        2. Arbitrary Write

    example7.c의 1번 메뉴에서는 임의 주소 읽기가, 2번 메뉴에서는 임의 주소 쓰기가 가능한 것을 확인할 수 있습니다.

    우선, system 함수의 주소를 구하기 위해 libc.so.6 라이브러리 주소를 릭해 보도록 하겠습니다.

    RELRO 보호기법이 적용되어 있다 하더라도 GOT에 라이브러리 주소가 저장되어 있기 때문에 GOT를 이용하면 libc.so.6 라이브러리의 주소를 구할 수 있습니다.

    menu 함수에 있는 puts@plt로부터 puts@got의 위치를 찾아 보겠습니다.
    puts@got의 주소는 0x8049fec인 것을 알 수 있습니다.
    ex)
        $ gdb -q ./example7
        Reading symbols from ./example7...(no debugging symbols found)...done.
        (gdb) disas menu
        Dump of assembler code for function menu:
            0x08048572 <+0>:	push   ebp
            0x08048573 <+1>:	mov    ebp,esp
            0x08048575 <+3>:	push   0x8048745
            0x0804857a <+8>:	call   0x8048420
            0x0804857f <+13>:	add    esp,0x4
            0x08048582 <+16>:	push   0x804874d
            0x08048587 <+21>:	call   0x8048420
            0x0804858c <+26>:	add    esp,0x4
            0x0804858f <+29>:	push   0x804875d
            0x08048594 <+34>:	call   0x8048420
            0x08048599 <+39>:	add    esp,0x4
            0x0804859c <+42>:	nop
            0x0804859d <+43>:	leave  
            0x0804859e <+44>:	ret    
        End of assembler dump.
        (gdb) x/2i 0x8048420
            0x8048420:	jmp    DWORD PTR ds:0x8049fec
            0x8048426:	xchg   ax,ax





































