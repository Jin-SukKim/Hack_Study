SSP :
    Disassembly 결과
    ex) no_ssp
        $ gdb -q ./no_ssp
        Reading symbols from ./no_ssp...(no debugging symbols found)...done.
        (gdb) disas func
        Dump of assembler code for function func:
            0x0804840b <+0>:	push   ebp
            0x0804840c <+1>:	mov    ebp,esp
            0x0804840e <+3>:	sub    esp,0x18
            0x08048411 <+6>:	mov    DWORD PTR [ebp-0x18],0x0
            0x08048418 <+13>:	mov    DWORD PTR [ebp-0x14],0x0
            0x0804841f <+20>:	mov    DWORD PTR [ebp-0x10],0x0
            0x08048426 <+27>:	mov    DWORD PTR [ebp-0xc],0x0
            0x0804842d <+34>:	sub    esp,0x8
            0x08048430 <+37>:	push   DWORD PTR [ebp+0x8]
            0x08048433 <+40>:	lea    eax,[ebp-0x18]
            0x08048436 <+43>:	push   eax
            0x08048437 <+44>:	call   0x80482e0 <strcpy@plt>
            0x0804843c <+49>:	add    esp,0x10
            0x0804843f <+52>:	nop
            0x08048440 <+53>:	leave  
            0x08048441 <+54>:	ret   
        End of assembler dump.
        (gdb) 

    ex) ssp
        $ gdb -q ./ssp
        Reading symbols from ./ssp...(no debugging symbols found)...done.
        (gdb) disas func
        Dump of assembler code for function func:
            0x0804846b <+0>:	push   ebp
            0x0804846c <+1>:	mov    ebp,esp
            0x0804846e <+3>:	sub    esp,0x38
            0x08048471 <+6>:	mov    eax,DWORD PTR [ebp+0x8]
            0x08048474 <+9>:	mov    DWORD PTR [ebp-0x2c],eax
            0x08048477 <+12>:	mov    eax,gs:0x14
            0x0804847d <+18>:	mov    DWORD PTR [ebp-0xc],eax
            0x08048480 <+21>:	xor    eax,eax
            0x08048482 <+23>:	mov    DWORD PTR [ebp-0x1c],0x0
            0x08048489 <+30>:	mov    DWORD PTR [ebp-0x18],0x0
            0x08048490 <+37>:	mov    DWORD PTR [ebp-0x14],0x0
            0x08048497 <+44>:	mov    DWORD PTR [ebp-0x10],0x0
            0x0804849e <+51>:	sub    esp,0x8
            0x080484a1 <+54>:	push   DWORD PTR [ebp-0x2c]
            0x080484a4 <+57>:	lea    eax,[ebp-0x1c]
            0x080484a7 <+60>:	push   eax
            0x080484a8 <+61>:	call   0x8048340 <strcpy@plt>
            0x080484ad <+66>:	add    esp,0x10
            0x080484b0 <+69>:	nop
            0x080484b1 <+70>:	mov    eax,DWORD PTR [ebp-0xc]
            0x080484b4 <+73>:	xor    eax,DWORD PTR gs:0x14
            0x080484bb <+80>:	je     0x80484c2 <func+87>
            0x080484bd <+82>:	call   0x8048330 <__stack_chk_fail@plt>
            0x080484c2 <+87>:	leave  
            0x080484c3 <+88>:	ret     
        End of assembler dump.
        (gdb) 

    이제 두 바이너리에 각각 buf 배열의 사이즈보다 긴 값을 인자로 전달해 스택 버퍼 오버플로우 취약점을 트리거해보도록 하겠습니다.
    ex)
        $ ./no_ssp AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        [1]    35367 segmentation fault (core dumped)  ./no_ssp AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        $ ./ssp AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        *** stack smashing detected ***: ./ssp terminated
        [1]    35374 abort (core dumped)  ./ssp AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

    no_ssp 바이너리의 경우 Segmentation fault 예외가 출력되며 프로그램이 비정상 종료되는 반면,
    ssp 바이너리는 __stack_chk_fail 함수가 호출되어 "stack smashing detected" 문자열을 출력하며 프로그램이 종료되는 것을 확인할 수 있습니다.

    


































