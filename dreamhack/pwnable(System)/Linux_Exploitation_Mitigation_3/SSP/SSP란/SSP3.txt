SSP :
    컴파일러에서 SSP 보호기법을 적용하는 경우 스택 배열을 사용하는 함수가 있으면
    함수의 시작 부분과 끝 부분에 ssp.c와 같이 stack_guard 체크 코드가 삽입됩니다.
    ex) ssp.c
        // gcc -o ssp ssp.c -m32
        #include <stdio.h>
        #include <string.h>
        void func(char *s){
            char buf[16] = {};
            /* 
            long canary = stack_guard; 
            */
            
            strcpy(buf, s);
            /* 
            if (canary != stack_guard)
                stack_chk_fail();
            */
        }
        
        int main(int argc, char *argv[]){
            func(argv[1]);
        }

    소스코드를 컴파일한 후 no_ssp와 ssp의 디스어셈블리 결과를 살펴보도록 하겠습니다.
    ex) no_ssp.c
        // gcc -o no_ssp no_ssp.c -m32 -fno-stack-protector
        #include <stdio.h>
        #include <string.h>
        void func(char *s){
            char buf[16] = {};
            
            strcpy(buf, s);
        }
        
        int main(int argc, char *argv[]){
            func(argv[1]);
        }

    Disassembly of no_ssp
    ex)
        $ gdb -q ./no_ssp
        Reading symbols from ./no_ssp...(no debugging symbols found)...done.
        (gdb) disas func
        Dump of assembler code for function func:
            0x0804840b <+0>:	push   ebp
            0x0804840c <+1>:	mov    ebp,esp
            0x0804840e <+3>:	sub    esp,0x18
            0x08048411 <+6>:	mov    DWORD PTR [ebp-0x18],0x0
            0x08048418 <+13>:	mov    DWORD PTR [ebp-0x14],0x0
            0x0804841f <+20>:	mov    DWORD PTR [ebp-0x10],0x0
            0x08048426 <+27>:	mov    DWORD PTR [ebp-0xc],0x0
            0x0804842d <+34>:	sub    esp,0x8
            0x08048430 <+37>:	push   DWORD PTR [ebp+0x8]
            0x08048433 <+40>:	lea    eax,[ebp-0x18]
            0x08048436 <+43>:	push   eax
            0x08048437 <+44>:	call   0x80482e0 <strcpy@plt>
            0x0804843c <+49>:	add    esp,0x10
            0x0804843f <+52>:	nop
            0x08048440 <+53>:	leave  
            0x08048441 <+54>:	ret   
        End of assembler dump.
        (gdb) 

    Disassembly of ssp
    ex)
        $ gdb -q ./ssp
        Reading symbols from ./ssp...(no debugging symbols found)...done.
        (gdb) disas func
        Dump of assembler code for function func:
            0x0804846b <+0>:	push   ebp
            0x0804846c <+1>:	mov    ebp,esp
            0x0804846e <+3>:	sub    esp,0x38
            0x08048471 <+6>:	mov    eax,DWORD PTR [ebp+0x8]
            0x08048474 <+9>:	mov    DWORD PTR [ebp-0x2c],eax
            0x08048477 <+12>:	mov    eax,gs:0x14
            0x0804847d <+18>:	mov    DWORD PTR [ebp-0xc],eax
            0x08048480 <+21>:	xor    eax,eax
            0x08048482 <+23>:	mov    DWORD PTR [ebp-0x1c],0x0
            0x08048489 <+30>:	mov    DWORD PTR [ebp-0x18],0x0
            0x08048490 <+37>:	mov    DWORD PTR [ebp-0x14],0x0
            0x08048497 <+44>:	mov    DWORD PTR [ebp-0x10],0x0
            0x0804849e <+51>:	sub    esp,0x8
            0x080484a1 <+54>:	push   DWORD PTR [ebp-0x2c]
            0x080484a4 <+57>:	lea    eax,[ebp-0x1c]
            0x080484a7 <+60>:	push   eax
            0x080484a8 <+61>:	call   0x8048340 <strcpy@plt>
            0x080484ad <+66>:	add    esp,0x10
            0x080484b0 <+69>:	nop
            0x080484b1 <+70>:	mov    eax,DWORD PTR [ebp-0xc]
            0x080484b4 <+73>:	xor    eax,DWORD PTR gs:0x14
            0x080484bb <+80>:	je     0x80484c2 <func+87>
            0x080484bd <+82>:	call   0x8048330 <__stack_chk_fail@plt>
            0x080484c2 <+87>:	leave  
            0x080484c3 <+88>:	ret     
        End of assembler dump.
        (gdb) 

    no_ssp의 디스어셈블리 결과와 달리, ssp에서는 함수의 프롤로그와 에필로그에 스택 카나리 검증 루틴이 추가된 것을 볼 수 있습니다.

































