SSP 설정 여부 확인 :
    SSP가 적용되어 있는 바이너리의 디스어셈블리 결과를 보면, 
    스택 카나리가 변조되었을 때 함수의 에필로그에서 stack_chk_fail 함수를 호출하는 코드를 확인할 수 있습니다.
    ex)
        $ gdb -q ./ssp
        Reading symbols from ./ssp...(no debugging symbols found)...done.
        (gdb) disas func
        Dump of assembler code for function func:
            0x0804846b <+0>:	push   ebp
            0x0804846c <+1>:	mov    ebp,esp
            0x0804846e <+3>:	sub    esp,0x38
            0x08048471 <+6>:	mov    eax,DWORD PTR [ebp+0x8]
            0x08048474 <+9>:	mov    DWORD PTR [ebp-0x2c],eax
            0x08048477 <+12>:	mov    eax,gs:0x14
            0x0804847d <+18>:	mov    DWORD PTR [ebp-0xc],eax
        …
            0x080484b4 <+73>:	xor    eax,DWORD PTR gs:0x14
            0x080484bb <+80>:	je     0x80484c2 <func+87>
            0x080484bd <+82>:	call   0x8048330 <__stack_chk_fail@plt>
            0x080484c2 <+87>:	leave  
            0x080484c3 <+88>:	ret     
        End of assembler dump.
        (gdb) 

    stack_chk_fail은 표준 라이브러리인 libc.so.6 에 존재하는 함수이기 때문에,
    바이너리에 이 함수의 심볼이 존재하는지 확인하는 것만으로 SSP 적용 여부를 알 수 있습니다.

    다음은 readelf를 이용해 SSP 보호기법의 적용 여부를 확인하는 방법입니다.
    ex)
        $ readelf -s ./no_ssp | grep stack_chk_fail
        $ readelf -s ./ssp | grep stack_chk_fail
            1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)
            53: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2

    SSP가 적용되어 있지 않은 no_ssp 바이너리는 stack_chk_fail 심볼이 없는 반면
    SSP가 적용되어 있는 ssp 바이너리에는 stack_chk_fail 심볼이 존재하는 것을 확인할 수 있습니다.






























