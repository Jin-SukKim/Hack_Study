Bypassing SSP - 1 :
    SSP 보호기법을 우회하기 위해선 스택 메모리에 존재하는 스택 카나리의 값을 변조시키지 않은 채로 익스플로잇을 해야 합니다.

    스택 오버플로우 취약점이 존재하는 다음 예시에서, SSP 보호기법을 우회하여 익스플로잇하는 실습을 해보도록 하겠습니다.

    example6.c의 main 함수에서 read 함수를 호출할 때, buf의 크기보다 더 큰 크기를 입력받아 스택 버퍼 오버플로우가 두 번 발생합니다.
    ex)
        // gcc -o example6 example6.c -m32 -mpreferred-stack-boundary=2
        #include <stdio.h>
            void give_shell(void){
            system("/bin/sh");
        }
        
        int main(void){
        
            char buf[32] = {};
            
            setvbuf(stdin, NULL, _IONBF, 0);
            setvbuf(stdout, NULL, _IONBF, 0);
            
            printf("Input1 : ");
            read(0, buf, 512);
            printf("Your input : %s", buf);
            printf("Input2 : ");
            read(0, buf, 512);
        }

    하지만 example6 바이너리에는 SSP가 설정되어 있기 때문에, 스택 카나리의 값을 알아내지 못한다면
    스택 버퍼 오버플로우 취약점만으로는 실행 흐름을 조작할 수 없습니다.

    example6.c의 line 18을 보면, %s 포맷 스트링을 이용해 buf의 내용을 출력하는 코드가 있습니다.

    printf 함수의 %s 포맷스트링은 NULL 바이트를 만날 때까지 출력해줍니다. 
    하지만, buf 배열의 끝이 NULL 바이트가 아니라면 buf 배열 밖의 메모리까지 출력할 수 있게 됩니다.

    우선 gdb를 이용해 buf 배열부터 스택 카나리 + 1까지의 오프셋을 구합니다.
    ex)
        $ gdb -q ./example6
        Reading symbols from ./example6...(no debugging symbols found)...done.
        (gdb) disas main
        Dump of assembler code for function main:
            0x0804855e <+0>:	push   ebp
            0x0804855f <+1>:	mov    ebp,esp
            0x08048561 <+3>:	sub    esp,0x24
            0x08048564 <+6>:	mov    eax,gs:0x14
            0x0804856a <+12>:	mov    DWORD PTR [ebp-0x4],eax
            …
            0x080485c0 <+98>:	add    esp,0x4
            0x080485c3 <+101>:	push   0x200
            0x080485c8 <+106>:	lea    eax,[ebp-0x24]
            0x080485cb <+109>:	push   eax
            0x080485cc <+110>:	push   0x0
            0x080485ce <+112>:	call   0x80483e0 <read@plt>
            …
            0x0804860c <+174>:	mov    edx,DWORD PTR [ebp-0x4]
            0x0804860f <+177>:	xor    edx,DWORD PTR gs:0x14
            0x08048616 <+184>:	je     0x804861d <main+191>
            0x08048618 <+186>:	call   0x8048400 <__stack_chk_fail@plt>
            0x0804861d <+191>:	leave  
            0x0804861e <+192>:	ret    
        End of assembler dump.
        (gdb) b *0x080485ce
        Breakpoint 1 at 0x80485ce
        (gdb) r
        Starting program: ~/example6 
        Input1 : 
        Breakpoint 1, 0x080485ce in main ()
        (gdb) x/3wx $esp
        0xffffd528: 0x00000000  0xffffd534  0x00000200
        (gdb) x/40wx 0xffffd534
        0xffffd534: 0x00000000  0x00000000  0x00000000  0x00000000
        0xffffd544: 0x00000000  0x00000000  0x00000000  0x00000000
        0xffffd554: 0xc5a20100  0x00000000  0xf7e19637  0x00000001
        0xffffd564: 0xffffd5f4  0xffffd5fc  0x00000000  0x00000000
        0xffffd574: 0x00000000  0xf7fb3000  0xf7ffdc04  0xf7ffd000
        0xffffd584: 0x00000000  0xf7fb3000  0xf7fb3000  0x00000000
        0xffffd594: 0x0416aed7  0x389780c7  0x00000000  0x00000000
        0xffffd5a4: 0x00000000  0x00000001  0x08048450  0x00000000
        0xffffd5b4: 0xf7fee010  0xf7fe8880  0xf7ffd000  0x00000001
        0xffffd5c4: 0x08048450  0x00000000  0x08048471  0x0804855e
        (gdb) p/x 0xffffd555-0xffffd534
        $1 = 0x21
        (gdb) 

    gdb로 확인한 결과 스택 카나리 + 1부터 buf까지의 오프셋은 0x21인 것을 알 수 있습니다.

    이를 이용하여 스택 카나리의 값을 구하는 파이썬 스크립트를 작성해 보도록 하겠습니다.

    해설 :
        read 함수에 브레이크포인트를 걸고 esp를 확인해보면 입력받는 주소가 0xffffd534임을 알 수 있습니다.
        example6.c 코드를 확인해보면 버퍼의 크기는 32 바이트이고, 16 진수로 변환하면 0x20이기 때문에 0xffffd534 + 0x20 = 0xffffd554이 됩니다. 
        이렇게 카나리의 주소를 알아낼 수 있습니다.




























