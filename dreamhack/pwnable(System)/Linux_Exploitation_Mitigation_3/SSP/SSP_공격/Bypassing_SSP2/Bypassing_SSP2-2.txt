Bypassing SSP - 2 :
    ssp_server는 fork를 이용한 서버 프로그램입니다. 
    ex)
        // gcc -o ssp_server ssp_server.c -m32
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <unistd.h>
        #include <errno.h>
        #include <string.h>
        #include <sys/types.h>
        #include <time.h> 
        #define PORT 31337
        char *name = "What is your name? ";
        char *bye = "See you again.";
        char *critical_msg = "THIS_FUNCTION_SHOULD_NOT_BE_CALLED";
        void critical(int fd){
            send(fd, critical_msg, strlen(critical_msg), 0);
        }
        void handler(int fd)
        {
            char buf[32] = {};
            send(fd, &fd, 4, 0);
            send(fd, name, strlen(name), 0);
            read(fd, buf, 1024);
            return;
        }
        int main(void)
        {
            int server_fd, new_socket, pid; 
            struct sockaddr_in address; 
            int opt = 1; 
            int addrlen = sizeof(address); 
            char *hello = "Hello from server"; 
            
            // Creating socket file descriptor 
            if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
            { 
                perror("socket failed"); 
                exit(EXIT_FAILURE); 
            } 
            
            if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, 
                                                        &opt, sizeof(opt))) 
            { 
                perror("setsockopt"); 
                exit(EXIT_FAILURE); 
            } 
            address.sin_family = AF_INET; 
            address.sin_addr.s_addr = INADDR_ANY; 
            address.sin_port = htons( PORT ); 
            
            if (bind(server_fd, (struct sockaddr *)&address,  
                                        sizeof(address))<0) 
            { 
                perror("bind failed"); 
                exit(EXIT_FAILURE); 
            } 
            if (listen(server_fd, 3) < 0) 
            { 
                perror("listen"); 
                exit(EXIT_FAILURE); 
            }
            while (1)
            {
                if ((new_socket = accept(server_fd, (struct sockaddr *)&address,  
                                (socklen_t*)&addrlen))<0) 
                { 
                    perror("accept"); 
                    exit(EXIT_FAILURE); 
                }
                pid = fork();
                if (pid == -1)
                {
                    perror("fork failed");
                    exit(EXIT_FAILURE);
                } 
                else if (pid)
                {
                    puts("Socket connected");
                    close(new_socket);
                } 
                else
                {
                    handler(new_socket);
                    send(new_socket, bye, strlen(bye), 0);
                    return 0;
                }
            }
            return 0; 
        }

    ssp_server는 31337번 포트에 TCP 서버를 연 후 클라이언트의 연결이 들어오면 자식 프로세스를 생성한 후 handler 함수를 호출합니다.
    handler 함수에서는 32 바이트 버퍼에 1024 바이트의 입력을 클라이언트로부터 받기 때문에 스택 버퍼 오버플로우가 존재합니다.
    하지만 ssp_server에는 SSP 보호기법이 적용되어 있기 때문에 스택 버퍼 오버플로우를 익스플로잇하기 위해서는 SSP를 우회해야 합니다.

    ssp_server의 부모 프로세스에서는 자식 프로세스의 시그널을 처리하는 루틴이 없기 때문에 
    자식 프로세스에서 SIGSEGV나 SIGABRT 예외가 발생해도 부모 프로세스는 종료되지 않습니다.
    만약 handler 함수가 정상적으로 리턴된다면 line 97에서 bye 문자열을 출력하고, 
    스택 카나리 검사가 실패해 자식 프로세스가 SIGABRT 예외로 종료된다면 bye 문자열을 출력하지 않습니다.

    bye 문자열의 출력 유무를 통해 스택 카나리 검사를 통과했는지 여부를 알 수 있다는 점과, 
    새로운 연결로부터 생성된 자식 프로세스와 부모 프로세스의 스택 카나리와 같다는 점을 이용하면
    브루트 포싱 공격을 통해 스택 카나리의 값을 한 바이트씩 알아낼 수 있습니다.








































