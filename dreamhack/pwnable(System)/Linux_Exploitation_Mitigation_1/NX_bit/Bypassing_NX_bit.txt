Bypassing NX Bit :
    NX bit가 설정되어 있을 경우에는 쓰기 권한과 실행 권한이 동시에 있는 메모리 영역이 존재하지 않습니다.
    그래서 example1 예제에서와 같이 셸코드를 스택 메모리에 저장해 실행 흐름을 스택으로 바꾸는 공격은 더 이상 사용할 수 없습니다. 
    공격자의 코드를 메모리에 저장할 수 없기 때문에 실행 권한이 있는 영역에 존재하는 코드만을 사용하여야 합니다.

    프로그램에 스택 버퍼 오버플로우가 존재한다면, 실행 흐름을 임의의 주소로 바꾸는 것은 여전히 가능합니다.
    NX bit가 적용되어 있는 상황에서 스택 메모리 등으로 실행 흐름을 직접 바꾸어 공격하는 것은 불가능하기 때문에,
    앞서 설명한 것처럼 메모리의 실행 가능한 영역에 있는 코드들을 활용해서 익스플로잇해야 합니다.
    C언어에서 printf와 같은 라이브러리 함수가 사용될 때, 프로그램은 메모리에 로딩된 라이브러리 파일에서 호출된 함수의 주소를 찾아 실행합니다. 
    그러므로 프로그램에서 호출된 함수 이외에 system과 같이 익스플로잇에 유용한 함수 코드들도 함께 로딩됩니다.

    HelloWorld.c는 Hello World!를 출력하는 간단한 예제를 통해 이를 알아보도록 하겠습니다.
    ex)
        // HelloWorld.c
        // gcc -o HelloWorld HelloWorld.c -m32
        #include <stdio.h>
        int main(void){
            printf("Hello World!\n");
        }

    ex)
        $ gdb -q ./HelloWorld
        Reading symbols from ./HelloWorld...(no debugging symbols found)...done.
        (gdb) b main
        Breakpoint 1 at 0x804840e
        (gdb) r
        Starting program: ~/HelloWorld 
        Breakpoint 1, 0x0804840e in main ()
        (gdb) info proc map
        process 106678
        Mapped address spaces:
            Start Addr   End Addr       Size     Offset objfile
            0x8048000  0x8049000     0x1000        0x0 ~/HelloWorld
            0x8049000  0x804a000     0x1000        0x0 ~/HelloWorld
            0x804a000  0x804b000     0x1000     0x1000 ~/HelloWorld
            0xf7e02000 0xf7e03000     0x1000        0x0 
            0xf7e03000 0xf7fb3000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb3000 0xf7fb5000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb5000 0xf7fb6000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
            0xf7fb6000 0xf7fb9000     0x3000        0x0 
            0xf7fd3000 0xf7fd4000     0x1000        0x0 
            0xf7fd4000 0xf7fd7000     0x3000        0x0 [vvar]
            0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
            0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
            0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
            0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
            0xfffdd000 0xffffe000    0x21000        0x0 [stack]
        (gdb) p printf
        $1 = {<text variable, no debug info>} 0xf7e4c670 <printf>
        (gdb) p scanf
        $2 = {<text variable, no debug info>} 0xf7e5e370 <scanf>
        (gdb) p exit
        $3 = {<text variable, no debug info>} 0xf7e319d0 <exit>
        (gdb) 

    HelloWorld 프로그램의 0xf7e03000 ~ 0xf7fb3000 영역이 libc.so.6 라이브러리 코드영역 주소이고,
    gdb 화면을 보면 프로그램에서 사용된 printf 함수 이외의 다른 함수들이 메모리에 존재한다는 것을 확인할 수 있습니다.

    프로그램에 스택 버퍼 오버플로우 취약점이 존재할 때, 
    리턴 주소를 이와 같은 방법으로 알아낸 라이브러리 함수의 주소로 바꾸면 해당하는 함수를 호출할 수 있습니다.
































    