ELF 동적 디버깅 - Process Attach :
    gdb를 이용하면 실행중인 프로세스를 디버깅할 수 있습니다.
    read_write는 사용자의 입력을 받아 문자열을 출력해주는 프로그램입니다.

    ex)
        $ ./read_write
        Input : abcd1234
        Your input : abcd1234

    gdb에 -p PID 혹은 --pid=PID를 인자로 전달하면 PID에 해당하는 프로세스에 gdb를 attach할 수 있습니다.

    우선, read_write를 실행하여 실행 중인 프로세스의 PID를 알아보겠습니다.
    실행 중인 프로세스의 PID를 확인하는 방법은 여러 가지가 있습니다.
    첫 번째 방법은 ps 프로그램을 이용하는 방법입니다.

    ex)
        $ ./read_write
        Input : 

    read_write 바이너리를 실행한 후, 아래와 같이 read_write 프로세스의 PID(50353)를 구할 수 있습니다.
    ex)
        $ ps -aux | grep read_write
        theori    50353  0.0  0.0   2204   520 pts/28   S+   21:50   0:00 ./read_write

    두 번째 방법은 pidof나 pgrep 프로그램을 사용하여 프로세스의 PID를 구하는 것입니다.

    pidof나 pgrep의 인자로 바이너리 이름을 전달하면 아래와 같이 해당 바이너리의 PID를 구할 수 있습니다.

    ex)
        $ pidof read_write
        50353
        $ pgrep read_write
        50353

    구한 PID를 이용해 gdb 프로세스 디버깅을 해보도록 하겠습니다.

    ex)
        (gdb) disas main
        Dump of assembler code for function main:
        ...
            0x080484ec <+49>:	push   0x80485d0
            0x080484f1 <+54>:	call   0x8048370 <printf@plt>
            0x080484f6 <+59>:	add    esp,0x10
            0x080484f9 <+62>:	sub    esp,0x8
            0x080484fc <+65>:	lea    eax,[ebp-0x4c]
            0x080484ff <+68>:	push   eax
            0x08048500 <+69>:	push   0x80485d9
            0x08048505 <+74>:	call   0x80483a0 <__isoc99_scanf@plt>
            0x0804850a <+79>:	add    esp,0x10
            0x0804850d <+82>:	sub    esp,0x8
            0x08048510 <+85>:	lea    eax,[ebp-0x4c]
            0x08048513 <+88>:	push   eax
            0x08048514 <+89>:	push   0x80485de
            0x08048519 <+94>:	call   0x8048370 <printf@plt>
        ...

    ex)
        $ ./read_write
        Input : 

    프로세스가 사용자의 입력을 받기 위해 실행 대기중일 때, 아래와 같이 gdb를 프로세스에 attach시켰습니다.

    ex)
        # gdb -q -p 50353
        Attaching to process 50353
        Reading symbols from /Linux_Exploitation_Mitigation/read_write...(no debugging symbols found)...done.
        Reading symbols from /lib/i386-linux-gnu/libc.so.6...(no debugging symbols found)...done.
        Reading symbols from /lib/ld-linux.so.2...(no debugging symbols found)...done.
        0xf7f8ffd9 in __kernel_vsyscall ()
        ...
        (gdb)

    scanf 함수가 호출된 이후인 0x804850a 주소에 브레이크포인트를 설정해 입력한 데이터를 메모리에서 확인해보도록 하겠습니다.

    ex)
        (gdb) b *0x0804850a
        Breakpoint 1 at 0x804850a
        (gdb) c
        Continuing.

    ex)
        $ ./read_write
        Input : abcd1234

    ex)
        Breakpoint 1, 0x0804850a in main ()
        (gdb) x/4wx $ebp-0x4c
        0xffaf0acc:	0x64636261	0x34333231	0x00000000	0x00000000
        (gdb) 

    입력한 문자열 "abcd1234"가 buf의 주소인 0xffaf0acc 주소에 저장되어 있는 것을 확인할 수 있습니다.

    이것으로 gdb의 간단한 사용법에 대해 알아보았습니다.


        명령어                          설명        
    info functions	            함수의 이름과 주소를 출력	
    disassemble main	        main 함수의 디스어셈블리를 출력	
    break	                    주소에 breakpoint를 설정	
    info breakpoints	        breakpoint 정보 출력	
    run	                        프로그램을 처음부터 실행	
    display	                    매 실행 시 인자로 전달된 값을 출력	
    continue	                다음 브레이크포인트까지 실행	
    si	                        step instruction, 명령어 1개 실행	
    finish	                    현재 함수를 모두 실행	
    info register	            레지스터 정보 출력	
    x/	                        지정된 메모리 영역을 특정 단위로 표현	
    p	                        print, 인자로 전달된 값을 출력	
    delete [break number]	    브레이크포인트 번호에 해당하는 브레이크포인트 삭제	
    quit	                    gdb 종료

ex)
    (gdb) info functions
    All defined functions:
    Non-debugging symbols:
    0x080482a8  _init
    0x080482e0  puts@plt
    0x080482f0  __libc_start_main@plt
    0x08048300  __gmon_start__@plt
    0x08048310  _start
    0x08048350  _dl_relocate_static_pie
    0x08048360  __x86.get_pc_thunk.bx
    0x08048370  deregister_tm_clones
    0x080483b0  register_tm_clones
    0x080483f0  __do_global_dtors_aux
    0x08048420  frame_dummy
    0x08048426  main
    0x0804844f  __x86.get_pc_thunk.ax
    0x08048460  __libc_csu_init
    0x080484c0  __libc_csu_fini
    0x080484c4  _fini
    
    (gdb) disassemble main
    Dump of assembler code for function main:
        0x08048426 <+0>:	push   ebp
        0x08048427 <+1>:	mov    ebp,esp
        0x08048429 <+3>:	push   ebx
        0x0804842a <+4>:	call   0x804844f <__x86.get_pc_thunk.ax>
        0x0804842f <+9>:	add    eax,0x1bd1
        0x08048434 <+14>:	lea    edx,[eax-0x1b20]
        0x0804843a <+20>:	push   edx
        0x0804843b <+21>:	mov    ebx,eax
        0x0804843d <+23>:	call   0x80482e0 <puts@plt>
        0x08048442 <+28>:	add    esp,0x4
        0x08048445 <+31>:	mov    eax,0x0
        0x0804844a <+36>:	mov    ebx,DWORD PTR [ebp-0x4]
        0x0804844d <+39>:	leave  
        0x0804844e <+40>:	ret 
    
    (gdb) break *0x08048426
    Breakpoint 1 at 0x8048426
    (gdb) break *0x0804843d
    Breakpoint 2 at 0x804843d
    (gdb) break *0x0804844e
    Breakpoint 3 at 0x804844e
    (gdb) info breakpoints
    Num     Type           Disp Enb Address    What
    1       breakpoint     keep y   0x08048426 <main>
    2       breakpoint     keep y   0x0804843d <main+23>
    3       breakpoint     keep y   0x0804844e <main+40>
    
    (gdb) run
    Starting program: ~/hellogdb 
    Breakpoint 1, 0x08048426 in main ()
    (gdb) display/3i $eip
    =>  0x8048426 <main>:	push   ebp
        0x8048427 <main+1>:	mov    ebp,esp
        0x8048429 <main+3>:	push   ebx
    
    (gdb) continue
    Continuing.
    Breakpoint 2, 0x0804843d in main ()
    1: x/3i $eip
    =>  0x804843d <main+23>:	call   0x80482e0 <puts@plt>
        0x8048442 <main+28>:	add    esp,0x4
        0x8048445 <main+31>:	mov    eax,0x0
    
    (gdb) si
    0x080482e0 in puts@plt ()
    1: x/3i $eip
    =>  0x80482e0 <puts@plt>:	jmp    *0x804a00c
        0x80482e6 <puts@plt+6>:	push   $0x0
        0x80482eb <puts@plt+11>:	jmp    0x80482d0
    
    (gdb) finish
    Run till exit from #0  0x080482e0 in puts@plt ()
    Hello GDB!
    0x08048442 in main ()
    1: x/3i $eip
    =>  0x8048442 <main+28>:	add    $0x4,%esp
        0x8048445 <main+31>:	mov    $0x0,%eax
        0x804844a <main+36>:	mov    -0x4(%ebp),%ebx
    
    (gdb) info register
    eax            0xb	11
    ecx            0x804b160	134525280
    edx            0xf7fac890	-134559600
    ebx            0x804a000	134520832
    esp            0xffffd640	0xffffd640
    ebp            0xffffd648	0xffffd648
    esi            0xf7fab000	-134565888
    edi            0x0	0
    eip            0x8048442	0x8048442 <main+28>
    eflags         0x246	[ PF ZF IF ]
    cs             0x23	35
    ss             0x2b	43
    ds             0x2b	43
    es             0x2b	43
    fs             0x0	0
    gs             0x63	99
    
    (gdb) x/w $esp
    0xffffd640:	134513888
    (gdb) x/wx $esp
    0xffffd640:	0x080484e0
    (gdb) x/s $esp
    0xffffd640:	"\340\204\004\b"
    (gdb) x/gx $esp
    0xffffd640:	0x00000000080484e0
    (gdb) x/c $esp
    0xffffd640:	-32 '\340'
    
    (gdb) p $eip
    $1 = (void (*)()) 0x8048442 <main+28>
    (gdb) ni
    0x08048445 in main ()
    (gdb) ni
    0x08048445 in main ()
    1: x/3i $eip
    =>  0x8048445 <main+31>:	mov    $0x0,%eax
        0x804844a <main+36>:	mov    -0x4(%ebp),%ebx
        0x804844d <main+39>:	leave
    (gdb) ni
    0x0804844a in main ()
    1: x/3i $eip
    =>  0x804844a <main+36>:	mov    -0x4(%ebp),%ebx
        0x804844d <main+39>:	leave  
        0x804844e <main+40>:	ret
    (gdb) ni
    0x0804844d in main ()
    1: x/3i $eip
    =>  0x804844d <main+39>:	leave  
        0x804844e <main+40>:	ret    
        0x804844f <__x86.get_pc_thunk.ax>:	mov    (%esp),%eax
    (gdb) ni
    Breakpoint 3, 0x0804844e in main ()
    1: x/3i $eip
    =>  0x804844e <main+40>:	ret    
        0x804844f <__x86.get_pc_thunk.ax>:	mov    (%esp),%eax
        0x8048452 <__x86.get_pc_thunk.ax+3>:	ret
    
    (gdb) delete 1
    (gdb) delete 2
    (gdb) delete 3
    (gdb) info breakpoint
    No breakpoints or watchpoints.
    
    (gdb) quit
    A debugging session is active.
        Inferior 1 [process 27535] will be killed.
    Quit anyway? (y or n) y
    ubuntu@dreamhack:~$











