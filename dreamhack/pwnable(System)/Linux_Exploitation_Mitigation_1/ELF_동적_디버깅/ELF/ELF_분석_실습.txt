ELF 동적 분석 실습 :
    example0.c는 1과 2의 덧셈 결과를 출력하는 예제입니다.

    example0로 output file 생성 후 gdb
    ex)
        gcc -o example0 example0.c

        option :
            -o : 출력 파일명을 지정할 때 사용합니다.
            -c : 링킹 과정을 진행 하지 않고 .o 파일인 오브젝트 파일까지만 생성 하게 됩니다.
            -S : 어셈블러까지 진행 하지 않고, 컴파일러까지의 출력은 .S 어셈블러 파일을 생성하게 됩니다.
            -O1 ~ -O3 : 최적화 수준을 지정합니다. 숫자가 클수록 높은 수준의 최적화를 하게 됩니다.
            -g : 디버깅을 위한 정보를 컴파일 하면서 생성하게 됩니다.
            -D : define 을 할수 있는 옵션입니다.
            -l (엘) : 라이브러리 이름을 지정합니다.
            -L : 추가 라이브러리 디렉토리를 지정합니다.
            -W : 모든 에러 메시지 출력
            -w : 모든 에러 메시지를 출력 하지 않음
            -I(아이) : 추가 헤더 파일이 있는 디렉토리를 지정합니다.

    다음은 example0을 gdb의 인자로 전달한 결과입니다.
    ex)
        $ gdb ./example0
        GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
        Copyright (C) 2016 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
        and "show warranty" for details.
        This GDB was configured as "x86_64-linux-gnu".
        Type "show configuration" for configuration details.
        For bug reporting instructions, please see:
        <http://www.gnu.org/software/gdb/bugs/>.
        Find the GDB manual and other documentation resources online at:
        <http://www.gnu.org/software/gdb/documentation/>.
        For help, type "help".
        Type "apropos word" to search for commands related to "word"...
        Reading symbols from ./example0...(no debugging symbols found)...done.
        (gdb) 

    gdb는 커맨드 라인 기반으로 동작하는 디버거로, 명령어 입력을 통해 다양한 기능을 수행할 수 있습니다.

    gdb에서 함수의 디스어셈블리 결과를 출력해주는 명령어는 disassemble, 혹은 disas입니다. 
    disas 명령어를 사용하여 main 함수의 디스어셈블리 결과를 보겠습니다.
    
    // https://blog.hexabrain.net/186
    ex) main함수의 Disassembly
        (gdb) disas main
        Dump of assembler code for function main:
            0x0804840b <+00>:	push   ebp
            0x0804840c <+01>:	mov    ebp,esp
            0x0804840e <+03>:	sub    esp,0xc
            0x08048411 <+06>:	mov    DWORD PTR [ebp-0x4],0x0
            0x08048418 <+13>:	mov    DWORD PTR [ebp-0x8],0x1
            0x0804841f <+20>:	mov    DWORD PTR [ebp-0xc],0x2
            0x08048426 <+27>:	mov    edx,DWORD PTR [ebp-0x8]
            0x08048429 <+30>:	mov    eax,DWORD PTR [ebp-0xc]
            0x0804842c <+33>:	add    eax,edx
            0x0804842e <+35>:	mov    DWORD PTR [ebp-0x4],eax
            0x08048431 <+38>:	push   DWORD PTR [ebp-0x4]
            0x08048434 <+41>:	push   0x80484d0
            0x08048439 <+46>:	call   0x80482e0 <printf@plt>
            0x0804843e <+51>:	add    esp,0x8
            0x08048441 <+54>:	mov    eax,0x0
            0x08048446 <+59>:	leave  
            0x08048447 <+60>:	ret    
        End of assembler dump.
        (gdb) 

    0x804842e 주소에 브레이크포인트를 설정해 val1 + val2의 결과값이 저장된 eax 레지스터의 값을 살펴보겠습니다.

    gdb에서 브레이크포인트를 설정하는 명령어는 break 혹은 b입니다.
    ex)
        (gdb) b *0x804842e
        Breakpoint 1 at 0x804842e
        (gdb) info break
        Num     Type           Disp Enb Address    What
        1       breakpoint     keep y   0x0804842e <main+35>
        (gdb) 

    디버깅 중인 프로세스의 정보를 출력해주는 명령어인 info를 사용해 브레이크포인트가 정상적으로 설정된 것을 확인할 수 있습니다.

    프로세스를 실행시켜 주는 명령어인 run (r)을 이용해 브레이크포인트가 설정된 지점까지 example0을 실행시켜 보겠습니다.
    ex)
        (gdb) r
        Starting program: ~/example0 
        
        Breakpoint 1, 0x0804842e in main ()
        (gdb) info reg
        eax            0x3	3
        ecx            0x97b9e553	-1749424813
        edx            0x1	1
        ebx            0x0	0
        esp            0xffffd5dc	0xffffd5dc
        ebp            0xffffd5e8	0xffffd5e8
        esi            0xf7fb2000	-134537216
        edi            0xf7fb2000	-134537216
        eip            0x804842e	0x804842e <main+35>
        eflags         0x206	[ PF IF ]
        cs             0x23	35
        ss             0x2b	43
        ds             0x2b	43
        es             0x2b	43
        fs             0x0	0
        gs             0x63	99
        (gdb) 

    eip 레지스터가 0x804842e인 것으로 보아 브레이크포인트를 설정했던 위치에서 실행이 멈춘 것을 확인할 수 있습니다.
    // EIP(Extended Instruction Pointer) = 확장된 명령 지시자
    //  - 다음에 CPU가 해야 하는 일이 무엇인지를 기억한다.

    레지스터나 변수의 값을 출력시켜주는 print (p) 명령어를 이용해 val1 + val2의 결과가 저장되어 있는 eax 레지스터의 값을 출력해보겠습니다.
    ex)
        (gdb) p $eax
        $1 = 3
        (gdb) 

    eax 레지스터에 3이 저장되어 있는 것을 볼 수 있습니다.

    0x8048439 주소에 브레이크포인트를 설정해 printf 함수의 인자들을 살펴보도록 하겠습니다.

    프로세스가 멈추어있는 상태에서 프로세스를 이어서 실행시켜 주는 명령어는 continue (c)입니다.
    만약 브레이크포인트가 설정되어 있다면 다음 브레이크포인트 지점까지 프로세스를 실행시킵니다.

    ex)
        (gdb) b*0x8048439
        Breakpoint 2 at 0x8048439
        (gdb) c
        Continuing.
        
        Breakpoint 2, 0x08048439 in main ()
        (gdb) 

    다음으로 스택 메모리를 살펴보겠습니다. x 명령어를 사용하면 인자로 주어진 주소의 메모리를 볼 수 있습니다.

    x 명령어는 또한 출력 타입을 지정해줄 수 있습니다.
    우선 esp 레지스터의 메모리를 word 타입으로 2개만큼(x/2wx) 출력해보도록 하겠습니다.
    
    ex)
        (gdb) x/2wx $esp
        0xffffd544:	0x080484d0	0x00000003

    x86 아키텍처의 호출 규약에 의해, printf 함수가 호출되는 시점의 스택 메모리에 함수의 인자들이 순서대로 저장되어 있는 것을 볼 수 있습니다.

    첫 번째 인자인 1 + 2 = %d\n 문자열의 주소 0x80484d0을 문자열 형태로(x/s) 출력해보겠습니다.
    ex)
        (gdb) x/s 0x080484d0
        0x80484d0:	"1 + 2 = %d\n"
        (gdb) 

    마지막으로 함수의 다음 인스트럭션까지 실행해주는 nexti (ni) 명령어를 이용해 printf 함수를 실행해보겠습니다.
    ex)
        (gdb) x/i $eip
        => 0x8048439 <main+46>:	call   0x80482e0 <printf@plt>
        (gdb) ni
        1 + 2 = 3
        0x0804843e in main ()
        (gdb) x/i $eip
        => 0x804843e <main+51>:	add    esp,0x8
        (gdb) 

    printf 함수가 실행되어 "1 + 2 = 3" 문자열이 출력되었습니다.
    










