Buffer Overflow in C++ :
    C++은 브라우저나 게임 엔진 등, 높은 성능을 요구하는 프로그램을 개발할 때 자주 사용되는 언어입니다.
    C++은 수많은 기능들을 제공하고, 끊임없는 버전 업데이트와 새로운 아이디어들이 추가되는 언어입니다. 
    그만큼 언어의 성능은 강력하며, 프로그래머가 할 수 있는 일도 많습니다. 
    그러나 C++은 C와 같이 프로그래머가 직접 메모리를 관리할 수 있는 여지가 있기 때문에 메모리 커럽션 취약점이 발생할 수 있습니다.

    C++로 작성된 프로그램에서 발생하는 메모리 커럽션들은 복잡한 문법으로 인해 C에 비해 잘 드러나지 않는 경우가 있습니다.
    이외에도 C++은 높은 추상화를 제공하기 때문에, 이런 높은 추상화 단계의 코드에서 취약점을 찾기 위해서는 
    C++에서 발생할 수 있는 보안 위협에 대해 정확히 이해해야 합니다.
    우선 C++에서 발생할 수 있는 버퍼 오버플로우 취약점에 살펴보도록 하겠습니다.

    버퍼 오버플로우 취약점은 가장 대표적인 메모리 커럽션 취약점입니다.
    이는 버퍼의 경계 검사가 정확히 이루어지지 않아 발생하는 취약점으로,
    버퍼에 할당된 영역을 넘어 다른 데이터를 오염시킬 수 있는 취약점입니다.

    ex)
        // g++ -o bof-1 bof-1.cpp
        #include <iostream>
        int main(void) {
            char buf[20];
            std::cin >> buf;
        }

    bof-1은 20 바이트 크기의 버퍼를 할당하고 std::cin 함수를 통해 문자열을 입력받습니다.
    std::cin은 입력받는 버퍼의 자료형에 따라 다양한 형태로 오버로딩된 함수 내용을 불러오는 표준 입력 함수입니다.
    그러나 char형인 buf에 입력받는 경우에는 길이 검증이 없어 버퍼 오버플로우가 발생합니다.

    ex)
        // g++ -o bof-2 bof-2.cpp
        #include <iostream>
        int main(void) {
            std::string buf;
            std::cin >> buf;
        }

    이 경우 bof-2와 같이 char형 버퍼에 문자열을 입력받는 것이 아닌, std::string 타입 버퍼에 입력받으면 문제는 해결됩니다.
    std::string은 char와는 다르게 입력받는 길이에 따라 자동으로 메모리를 할당하기 때문에 버퍼 오버플로우가 발생하지 않습니다.

    






















