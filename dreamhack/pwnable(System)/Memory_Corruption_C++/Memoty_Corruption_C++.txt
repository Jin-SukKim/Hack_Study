Memory Corruption in C++ :

    1) Buffer Overflow in C++
        cin 함수는 길이 검증이 없기 때문에 string과 같이 메모리를 할당하지 않는 타입을 사용한다면 버퍼 오버플로우가 발생합니다.
        C++에서 데이터 관리를 편하게 하기 위해 벡터와 큐와 같은 컨테이너들을 지원합니다.
        그러나 올바르지 않게 사용한다면 버퍼 오버플로우가 발생할 수 있습니다.

    2) Uninitialized Value :
        지역 변수나 선언된 클래스의 멤버 변수에 대한 초기화가 이루어지지 않으면 스택에 존재하는 잔여 값을 가지고 있기 때문에 
        메모리 릭 혹은 임의 주소 쓰기 취약점 등으로 이어질 수 있습니다.

    3) Use-After-Free :
        해제된 객체에 대해 다시 접근하려 할 때 Use-After-Free가 발생합니다. 
        만약 공격자가 해제된 메모리에 값을 쓸 수 있다면 다른 취약점으로 연계하여 공격할 수 있습니다.
        서로 다른 두 개의 스마트 포인터가 같은 객체를 가리키거나 다른 레퍼런스 카운트 값을 가지게 될 경우에 Use-After-Free가 발생합니다.
        클래스를 복사할 때 호출되는 복사 생성자에서 객체를 새롭게 할당하지 않으면 두 개 이상의 포인터가 같은 영역을 가리킬 수 있습니다.

    4) Type Confusion :
        프로그램에서 사용하는 변수나 객체를 선언 혹은 초기화되었을 때와 다른 타입으로 사용할 때 발생하는 취약점입니다.
        잘못된 타입 캐스팅을 사용하여 올바르지 않은 클래스의 타입을 가지게 된다면 Type Confusion이 발생합니다.

    5) String in C++ :
        string 타입의 객체를 사용할 때 올바르지 않은 함수 사용이나 예외 처리 등이 존재하지 않을 경우에 메모리 릭 혹은 DoS가 발생할 수 있습니다.


































