Return Address Overwrite - 스택 버퍼 오버플로우 :
    example1.c에서는 프로그램의 argv[1]을 vuln 함수의 인자로 전달합니다.

    vuln 함수에서는 src 버퍼를 buf 버퍼에 strcpy 함수를 이용해 복사합니다.

    strcpy 함수는 피복사 버퍼에 대한 길이 검증이 없기 때문에, 프로그램의 첫 번째 인자에 buf 배열의 크기보다 긴 문자열을 넣으면 스택 버퍼 오버플로우가 발생합니다.

    이때의 vuln 함수의 메모리 구조는 다음과 같습니다. 사진 - memory

    x86 아키텍처 호출 규약에 의해 vuln 함수가 호출되면 vuln 함수의 인자인 src 문자열 포인터가 스택에 먼저 쌓입니다. 
    이후 vuln함수의 리턴 주소가 쌓이고, 함수의 프롤로그에서 ebp 레지스터를 저장한 다음 지역 변수의 공간을 할당합니다.

    취약점이 존재하는 vuln 함수에 브레이크포인트를 설정한 후 첫 번째 인자와 함께 example1 바이너리를 실행해 보겠습니다.
    브레이크포인트에서의 스택 메모리를 보면, 첫 4 바이트는 vuln 함수의 리턴 주소이고 다음 4 바이트는 vuln 함수의 인자인 argv[1]의 주소임을 알 수 있습니다.

    ex)
        (gdb) p vuln
        $1 = {<text variable, no debug info>} 0x804843b <vuln>
        (gdb) b*0x804843b
        Breakpoint 1 at 0x804843b
        (gdb) r aaaabbbbccccdddd
        Starting program: ~/example1 aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll
        
        Breakpoint 1, 0x0804843b in vuln ()
        (gdb) x/2wx $esp
        0xffffd520:	0x08048494	0xffffd74a
        (gdb) x/i 0x08048494
            0x8048494 <main+30>:	add    $0x4,%esp
        (gdb) x/s 0xffffd74a
        0xffffd74a:	"aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll"
        
        (gdb) 
        (gdb) disas vuln
        Dump of assembler code for function vuln:
            0x0804843b <+0>:	push   ebp
            0x0804843c <+1>:	mov    ebp,esp
            0x0804843e <+3>:	sub    esp,0x20
            0x08048441 <+6>:	mov    ecx,0x0
            0x08048446 <+11>:	mov    eax,0x20
            0x0804844b <+16>:	and    eax,0xfffffffc
            0x0804844e <+19>:	mov    edx,eax
            0x08048450 <+21>:	mov    eax,0x0
            0x08048455 <+26>:	mov    DWORD PTR [ebp+eax*1-0x20],ecx
            0x08048459 <+30>:	add    eax,0x4
            0x0804845c <+33>:	cmp    eax,edx
            0x0804845e <+35>:	jb     0x8048455 <vuln+26>
            0x08048460 <+37>:	push   DWORD PTR [ebp+0x8]
            0x08048463 <+40>:	lea    eax,[ebp-0x20]
            0x08048466 <+43>:	push   eax
            0x08048467 <+44>:	call   0x8048300 <strcpy@plt>
            0x0804846c <+49>:	add    esp,0x8
            0x0804846f <+52>:	mov    eax,0x0
            0x08048474 <+57>:	leave  
            0x08048475 <+58>:	ret  
        End of assembler dump.
        (gdb) 

    이제 strcpy 함수가 실행되기 직전에 브레이크포인트를 설정해 인자들을 살펴보겠습니다.
    ex)
        (gdb) x/20i vuln
        =>  0x804843b <vuln>:	push   ebp
            ...
            0x8048467 <vuln+44>:	call   0x8048300 <strcpy@plt>
            ...
        (gdb) b *0x8048467
        Breakpoint 2 at 0x8048467
        (gdb) c
        Continuing.
        
        Breakpoint 2, 0x08048467 in vuln ()
        (gdb) x/2wx $esp
        0xffffd4f4:	0xffffd4fc	0xffffd74a

    스택을 살펴보면 첫 번째 인자인 buf 주소와 두 번째 인자인 argv[1]의 주소가 저장되어 있는 것을 볼 수 있습니다.

    strcpy 함수를 실행해 보겠습니다.
    ex)
        (gdb) ni
        0x0804846c in vuln ()
        (gdb) x/20wx 0xffffd4fc
        0xffffd4fc:	0x61616161	0x62626262	0x63636363	0x64646464
        0xffffd50c:	0x65656565	0x66666666	0x67676767	0x68686868
        0xffffd51c:	0x69696969	0x6a6a6a6a	0x6b6b6b6b	0x6c6c6c6c
        0xffffd52c:	0xf7e1b600	0x00000002	0xffffd5c4	0xffffd5d0
        0xffffd53c:	0x00000000	0x00000000	0x00000000	0xf7fb5000
        (gdb) 

    strcpy 함수의 첫 번째 인자인 buf(0xffffd4fc) 에 argv[1] 의 문자열이 복사된 것을 볼 수 있습니다.

    argv[1]에 buf의 길이인 32 바이트보다 긴 문자열을 주었기 때문에
    vuln의 리턴 주소가 저장된 0xffffd520 너머까지 argv[1] 문자열이 복사된 것을 확인할 수 있습니다.

    



























