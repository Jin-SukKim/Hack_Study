Out Of Boundary - 3 :
    ex)
        //oob-3.c
        #include <stdio.h>
        int main(void) {
            int idx;
            int buf[10];
            int dummy[7];
            int win;
            
            printf("Which index? ");
            scanf("%d", &idx);
            
            if(idx < 0)
                idx = -idx;
            idx = idx % 10; // No more OOB!@!#!
            
            printf("Value: ");
            scanf("%d", &buf[idx]);
            
            printf("idx: %d, value: %d\n", idx, buf[idx]);
            
            if(win == 31337){
                printf("Theori{-----------redacted---------}");
            }
        }

    oob-3.c는 oob-2.c와는 다르게 idx가 음수일 경우 이를 양수로 바꿔주는 코드가 추가되었습니다. 
    line 14에 들어가게 되는 idx 값은 양수가 되고, 10으로 나머지 연산을 했을 때 값의 범위는 0부터 9까지기 때문에 아무 문제가 없어 보입니다.

    그러나 C언어의 정수 표현에 대해 생각해보면, 뭔가 이상한 부분이 있다는 걸 알 수 있습니다.
    몇 가지 idx 값에 따라 line 14가 어떻게 실행되는지 자세히 살펴보겠습니다.

        1) idx = 1 (line 14) -> idx = 1 (line 15)
        2) idx = -100 (line 14) -> idx = 100 (line 15)
        3) idx = -10000 (line 14) -> idx = 10000 (line 15)
        4) idx = -pow(2, 31) (line 14) -> idx = -pow(2, 31) (line 15)

    마지막으로 나타나 있는 예제가 직관적으로 이해되지 않을 수 있습니다. 
    왜 저런 결과가 되는지 고민한 후 정답 탭을 눌러 해설을 확인해주시기 바랍니다.

ex)
    int의 size 는 4byte = 32 bit 즉 0부터 31bit 까지가 int의 범위이다.
    이 이후는 오버플로우가 발생 -> 제일 작은 int의 수로 바뀐다 = 음수로 바뀐다.
    이 성질을 이용해 오버플로우를 강제로 발생 시킨다.

    bash-3.2$ ./oob-3
    Which index? 2147483648
    Value : 31337
    idx: -8, value: 31337
    Theori{9129d686934b05495bfa9d97058be82a}

    bash-3.2$ ./oob-3
    Which index? -2147483648
    Value : 31337
    idx: -8, value: 31337
    Theori{9129d686934b05495bfa9d97058be82a}

    int의 범위는 -2^31 ~ 2^31-1 이다 (-2,147,483,648 ~ 2,147,483,647) = (2진수로 1000 0000 0000 0000 ~ 2진수로 0111 1111 1111 1111)
    int의 양수의 최대값이 2,147,483,648이 아닌 이유는 양수에 0이 포함되기 때문이다. 
    0~2,147,483,647 (2진수로 0000 0000 0000 0000 ~ 2진수로 0111 1111 1111 1111)
    index의 값에 -2^31을 입력하면 line 14에 의해 양수로 바뀌지만 2^31은 int의 범위에서 벗어나기 때문에 오버플로우가 발생한다.
    int에서 1의 값이 더 많아져 오버플로우가 발생시 int는 제일 작은 -2^31로 바뀌게 되고 line 14에 의해 양수로 바뀐다 해도
    결국 음수(-)값으로 변환되어 나머지 기능들을 수행한다.
    2,147,483,647 (2진수로 0111 1111 1111 1111)에 1을 더할시 2진수로 1000 0000 0000 0000이 된다.
    unsigned int가 아니기 때문에 최상위비트(MSB)가 1로 설정되 음수가 되고, 최소값인 -2,147,483,648가 된다.


풀이 :

    C언어에서 int형으로 표현 가능한 정수의 범위는 -pow(2, 31) ~ pow(2, 31) - 1입니다. (-2,147,483,648 ~ 2,147,483,647)
    int형은 32비트이기 때문에 총 pow(2, 32)개의 수를 표현할 수 있습니다. 
    int형은 0을 포함하기 때문에 표현할 수 있는 음의 정수의 갯수와 양의 정수의 갯수는 다릅니다.

    int 형에서 -pow(2,31)은 표현 가능하지만 pow(2,31)은 표현 가능하지 않습니다.
    pow(2,31)은 표현 가능한 최대 정수보다 하나 더 크기 때문에 이는 -pow(2,31)과 같은 값이 됩니다.

    oob-3.c를 다시 살펴보겠습니다. 
    지금까지 논의한 바에 따르면, idx에 -pow(2, 31)을 넣었을 경우 line 14에서 절대값을 구하는 연산을 수행한 후에도 -2**31이 그대로 저장됩니다.
    그렇다면 line 15에서 idx = idx % 10을 할 때 idx에 음수가 저장되고,
    이는 buf 배열의 올바른 인덱스 범위를 벗어나기 때문에 OOB가 발생합니다.

    이를 근본적으로 막기 위해서는 idx를 int형이 아닌 unsigned int형으로 선언하거나, 
    인덱스를 입력받은 이후에 if(idx < 0 || idx >= 10)과 같은 경계 검사 구문을 추가해야 합니다.



















